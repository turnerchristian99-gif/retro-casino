<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Retro Royal</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    .animate-spin {
      animation: spin 1s linear infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: .5; }
    }
    .animate-pulse {
      animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }
    
    /* Mobile Responsive Overrides */
    @media (max-width: 640px) {
      /* Make text more readable on mobile */
      body {
        font-size: 14px;
      }
      
      /* Reduce padding/margins on mobile */
      .max-w-7xl, .max-w-6xl, .max-w-5xl {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }
      
      /* Make cards smaller on mobile */
      .card-mini {
        width: 2.5rem !important;
        height: 3.5rem !important;
        font-size: 0.6rem !important;
      }
      
      /* Poker table adjustments */
      .poker-table-mobile {
        min-height: 300px !important;
        border-radius: 40px !important;
        border-width: 6px !important;
        padding: 1rem !important;
        padding-top: 3rem !important;
      }
      
      /* Community cards row - stack on mobile */
      .community-cards-container {
        flex-direction: column !important;
        gap: 0.75rem !important;
      }
      
      /* Player controls - full width on mobile */
      .player-controls-mobile {
        grid-template-columns: 1fr !important;
      }
      
      /* Reduce avatar sizes on mobile */
      .opponent-avatar {
        width: 3rem !important;
        height: 3rem !important;
        font-size: 1.25rem !important;
      }
      
      /* Stack game controls vertically on mobile */
      .game-controls-stack {
        flex-direction: column !important;
      }
      
      /* Make buttons touch-friendly (minimum 44px) */
      button {
        min-height: 44px;
        min-width: 44px;
      }
      
      /* Reduce font sizes in tight spaces */
      .text-2xl { font-size: 1.25rem !important; }
      .text-xl { font-size: 1.125rem !important; }
      .text-lg { font-size: 1rem !important; }
      
      /* Make modals full-screen on mobile */
      .modal-container {
        max-width: 100% !important;
        max-height: 100vh !important;
        border-radius: 0 !important;
      }
      
      /* Reduce grid gaps on mobile */
      .grid {
        gap: 0.75rem !important;
      }
      
      /* Make strategy grid smaller on mobile */
      .strategy-grid-mobile {
        grid-template-columns: repeat(6, minmax(0, 1fr)) !important;
      }
      
      /* Bullshit/Spades hand - scrollable on mobile */
      .hand-container-mobile {
        overflow-x: auto !important;
        -webkit-overflow-scrolling: touch;
        display: flex !important;
        flex-wrap: nowrap !important;
      }
      
      /* Navigation - compact on mobile */
      nav h1 {
        font-size: 1rem !important;
      }
      
      nav button span:last-child {
        display: none !important;
      }
    }
    
    /* Landscape mobile adjustments */
    @media (max-width: 896px) and (orientation: landscape) {
      .poker-table-mobile {
        min-height: 200px !important;
      }
      
      .opponent-avatar {
        width: 2.5rem !important;
        height: 2.5rem !important;
      }
    }
    
    /* Tablet adjustments */
    @media (min-width: 641px) and (max-width: 1024px) {
      .card-mini {
        width: 3rem !important;
        height: 4.25rem !important;
      }
    }
  </style>
    .animate-in {
      animation: fadeIn 0.5s ease-in;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes spin {
      from { transform: translateY(-50%) rotate(0deg); }
      to { transform: translateY(-50%) rotate(360deg); }
    }
  </style>
  <script type="module">
    /* eslint-disable */
    /* global */
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { 
      getFirestore, 
      doc, 
      setDoc, 
      onSnapshot, 
      updateDoc,
      getDoc,
      collection,
      query,
      where,
      getDocs,
      deleteDoc,
      serverTimestamp,
      orderBy,
      limit
    } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
    import { 
      getAuth, 
      signInWithEmailAndPassword, 
      createUserWithEmailAndPassword,
      onAuthStateChanged,
      signOut,
      updateProfile,
      deleteUser,
      GoogleAuthProvider,
      signInWithPopup,
      sendPasswordResetEmail
    } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';

    // Firebase Configuration
    const firebaseConfig = {
      apiKey: "AIzaSyC9nLHaL7Lc050imleIUeuq8EKD4Fi5qHU",
      authDomain: "retro-royal-casino.firebaseapp.com",
      projectId: "retro-royal-casino",
      storageBucket: "retro-royal-casino.firebasestorage.app",
      messagingSenderId: "441287288010",
      appId: "1:441287288010:web:faa72345e09aa619138033",
      measurementId: "G-3ZEK75NN35"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const appId = 'strategy-poker-hub';

    const GAME_TYPES = { 
      STRATEGY: 'STRATEGY', 
      POKER: 'POKER',
      BULLSHIT: 'BULLSHIT',
      SPADES: 'SPADES'
    };
    const SUITS = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
    const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];

    // Game State
    let currentUser = null;
    let currentPage = 'auth';
    let gameData = null;
    let unsubscribe = null;
    let isMultiplayer = false;
    let gameId = '';
    let selectedStrategyNode = null;
    let betAmount = 50;
    let ffActive = false;
    let resolutionStarted = false;
    let currentLobbyId = null;
    let lobbyUnsubscribe = null;
    let availableLobbies = [];
    let aiPlayerCount = 3;
    let userStats = {
      pokerWins: 0,
      strategyWins: 0,
      bullshitWins: 0,
      spadesWins: 0,
      totalWins: 0,
      nodesSecured: 0,
      gamesPlayed: 0,
      totalChips: 2000,
      avatar: 'üë§'
    };
    
    // Available avatars
    const AVATARS = [
      'üë§', 'ü§ñ', 'üë®‚Äçüíª', 'üë©‚Äçüíª', 'üßë‚ÄçüöÄ', 'üë®‚ÄçüöÄ', 'üë©‚ÄçüöÄ',
      'ü¶æ', 'üéÆ', 'üéØ', '‚ö°', 'üî•', 'üíé', 'üëë',
      'üé≤', 'üÉè', 'üé∞', 'üèÜ', '‚≠ê', 'üí´', 'üåü',
      'ü¶Ö', 'ü¶Å', 'üê∫', 'ü¶à', 'üêâ', 'ü¶ñ', 'ü¶Ç'
    ];

    // Utility Functions
    const generateDeck = () => {
      const deck = [];
      for (const suit of SUITS) {
        for (const rank of RANKS) {
          deck.push({ suit, rank });
        }
      }
      return deck.sort(() => Math.random() - 0.5);
    };

    const getRankValue = (rank) => RANKS.indexOf(rank);

    const evaluateHand = (playerCards, communityCards) => {
      const allCards = [...playerCards, ...communityCards];
      if (allCards.length < 2) return 0;
      const ranks = allCards.map(c => getRankValue(c.rank));
      const suits = allCards.map(c => c.suit);
      
      const rankCounts = {};
      ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
      const counts = Object.values(rankCounts).sort((a, b) => b - a);
      
      const isFlush = suits.some(s => suits.filter(x => x === s).length >= 5);
      const sortedRanks = [...new Set(ranks)].sort((a, b) => b - a);
      let isStraight = false;
      for (let i = 0; i <= sortedRanks.length - 5; i++) {
        if (sortedRanks[i] - sortedRanks[i + 4] === 4) {
          isStraight = true;
          break;
        }
      }
      
      if (!isStraight && sortedRanks.includes(12) && sortedRanks.includes(0) && 
          sortedRanks.includes(1) && sortedRanks.includes(2) && sortedRanks.includes(3)) {
        isStraight = true;
      }
      
      if (isStraight && isFlush) return 8000 + Math.max(...ranks);
      if (counts[0] === 4) return 7000 + Math.max(...ranks);
      if (counts[0] === 3 && counts[1] === 2) return 6000 + Math.max(...ranks);
      if (isFlush) return 5000 + Math.max(...ranks);
      if (isStraight) return 4000 + Math.max(...ranks);
      if (counts[0] === 3) return 3000 + Math.max(...ranks);
      if (counts[0] === 2 && counts[1] === 2) return 2000 + Math.max(...ranks);
      if (counts[0] === 2) return 1000 + Math.max(...ranks);
      return Math.max(...ranks);
    };

    const evaluateHandName = (playerCards, communityCards) => {
      const allCards = [...playerCards, ...communityCards];
      if (allCards.length < 2) return null;
      const ranks = allCards.map(c => getRankValue(c.rank));
      const suits = allCards.map(c => c.suit);
      
      const rankCounts = {};
      ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
      const counts = Object.values(rankCounts).sort((a, b) => b - a);
      
      const isFlush = suits.some(s => suits.filter(x => x === s).length >= 5);
      const sortedRanks = [...new Set(ranks)].sort((a, b) => b - a);
      let isStraight = false;
      for (let i = 0; i <= sortedRanks.length - 5; i++) {
        if (sortedRanks[i] - sortedRanks[i + 4] === 4) {
          isStraight = true;
          break;
        }
      }
      
      if (!isStraight && sortedRanks.includes(12) && sortedRanks.includes(0) && 
          sortedRanks.includes(1) && sortedRanks.includes(2) && sortedRanks.includes(3)) {
        isStraight = true;
      }
      
      if (isStraight && isFlush) return 'Straight Flush';
      if (counts[0] === 4) return 'Four of a Kind';
      if (counts[0] === 3 && counts[1] === 2) return 'Full House';
      if (isFlush) return 'Flush';
      if (isStraight) return 'Straight';
      if (counts[0] === 3) return 'Three of a Kind';
      if (counts[0] === 2 && counts[1] === 2) return 'Two Pair';
      if (counts[0] === 2) return 'One Pair';
      
      const highCard = RANKS[Math.max(...ranks)];
      return `High Card (${highCard})`;
    };

    // User Stats Functions
    const loadUserStats = async (userId) => {
      try {
        const statsDoc = await getDoc(doc(db, 'users', userId, 'stats', 'gameplay'));
        if (statsDoc.exists()) {
          userStats = { avatar: 'üë§', ...statsDoc.data() }; // Ensure avatar has default
        } else {
          // Initialize stats if they don't exist
          userStats = {
            pokerWins: 0,
            strategyWins: 0,
            totalWins: 0,
            nodesSecured: 0,
            gamesPlayed: 0,
            totalChips: 2000,
            avatar: 'üë§'
          };
          await saveUserStats(userId);
        }
      } catch (error) {
        console.error('Error loading stats:', error);
      }
    };

    const saveUserStats = async (userId) => {
      try {
        await setDoc(doc(db, 'users', userId, 'stats', 'gameplay'), userStats);
      } catch (error) {
        console.error('Error saving stats:', error);
      }
    };

    const updateStats = async (updates) => {
      if (!currentUser) return;
      userStats = { ...userStats, ...updates };
      await saveUserStats(currentUser.uid);
      if (currentPage === 'profile') {
        render();
      }
    };

    const getRank = (wins) => {
      if (wins >= 100) return 'Legend';
      if (wins >= 50) return 'Master';
      if (wins >= 25) return 'Veteran';
      if (wins >= 10) return 'Vanguard';
      if (wins >= 5) return 'Specialist';
      return 'Recruit';
    };

    const getRankInfo = (wins) => {
      const ranks = [
        { name: 'Recruit', minWins: 0, maxWins: 4, color: '#64748b', icon: 'üî∞', description: 'New operator entering the neural network', bonus: 'Welcome Package: 2000 Credits' },
        { name: 'Specialist', minWins: 5, maxWins: 9, color: '#3b82f6', icon: '‚ö°', description: 'Proven tactical capability in field operations', bonus: '+10% starting energy in Strategy' },
        { name: 'Vanguard', minWins: 10, maxWins: 24, color: '#8b5cf6', icon: 'üéØ', description: 'Elite operative with command authority', bonus: '+200 starting chips in Poker' },
        { name: 'Veteran', minWins: 25, maxWins: 49, color: '#ec4899', icon: 'üíé', description: 'Seasoned warrior of countless victories', bonus: '+2 starting nodes in Strategy' },
        { name: 'Master', minWins: 50, maxWins: 99, color: '#f59e0b', icon: 'üëë', description: 'Master strategist dominating the battlefield', bonus: '+500 starting chips & +15% energy' },
        { name: 'Legend', minWins: 100, maxWins: 999999, color: '#eab308', icon: '‚≠ê', description: 'Legendary status - the pinnacle of achievement', bonus: 'All bonuses + Special cosmetics' }
      ];
      
      return ranks.find(r => wins >= r.minWins && wins <= r.maxWins) || ranks[0];
    };

    const getNextRank = (wins) => {
      const ranks = [
        { name: 'Specialist', wins: 5 },
        { name: 'Vanguard', wins: 10 },
        { name: 'Veteran', wins: 25 },
        { name: 'Master', wins: 50 },
        { name: 'Legend', wins: 100 }
      ];
      
      return ranks.find(r => wins < r.wins) || null;
    };

    const getRankProgress = (wins) => {
      const current = getRankInfo(wins);
      if (current.name === 'Legend') return 100;
      const next = getNextRank(wins);
      if (!next) return 100;
      const progress = ((wins - current.minWins) / (next.wins - current.minWins)) * 100;
      return Math.min(Math.max(progress, 0), 100);
    };

    // Icon Components (simple SVG replacements)
    const icons = {
      trophy: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path><path d="M4 22h16"></path><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path></svg>',
      dice: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"></rect><path d="M16 8h.01"></path><path d="M8 8h.01"></path><path d="M8 16h.01"></path><path d="M16 16h.01"></path><path d="M12 12h.01"></path></svg>',
      refresh: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"></path><path d="M21 3v5h-5"></path></svg>',
      logout: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" x2="9" y1="12" y2="12"></line></svg>',
      user: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>',
      shield: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10"></path></svg>',
      settings: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"></circle><path d="M12 1v6m0 6v6m0-12a3 3 0 0 1 3 3m-3 3a3 3 0 0 1-3-3m12-3h-6m-6 0H1m12 12h-6m-6 0H1"></path></svg>',
      trash: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18"></path><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path></svg>',
      arrowLeft: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m12 19-7-7 7-7"></path><path d="M19 12H5"></path></svg>',
      coins: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="8" cy="8" r="6"></circle><path d="M18.09 10.37A6 6 0 1 1 10.34 18"></path><path d="M7 6h1v4"></path><path d="m16.71 13.88.7.71-2.82 2.82"></path></svg>',
      globe: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20"></path><path d="M2 12h20"></path></svg>',
      cpu: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect width="16" height="16" x="4" y="4" rx="2"></rect><rect width="6" height="6" x="9" y="9" rx="1"></rect><path d="M15 2v2"></path><path d="M15 20v2"></path><path d="M2 15h2"></path><path d="M2 9h2"></path><path d="M20 15h2"></path><path d="M20 9h2"></path><path d="M9 2v2"></path><path d="M9 20v2"></path></svg>',
      zap: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2"><path d="M13 2L3 14h8l-1 8 10-12h-8l1-8z"></path></svg>',
      activity: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 12h-4l-3 9L9 3l-3 9H2"></path></svg>',
      target: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle></svg>',
      radio: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="2"></circle><path d="M4.93 4.93a10 10 0 0 1 14.14 0"></path><path d="M8.46 8.46a5 5 0 0 1 7.08 0"></path></svg>',
      alertTriangle: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><path d="M12 9v4"></path><path d="M12 17h.01"></path></svg>',
      camera: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"></path><circle cx="12" cy="13" r="3"></circle></svg>',
      save: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>',
      info: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg>',
      sword: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14.5 17.5 3 6V3h3l11.5 11.5"></path><path d="M13 19 9 15"></path><path d="m16 16 5 5"></path><path d="m19 13 2 2"></path></svg>',
      shieldIcon: '<svg class="inline-block" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path></svg>'
    };

    // Render Functions
    function render() {
      const root = document.getElementById('root');
      
      // Additional safety check - if user exists but has no email, force auth page
      if (currentUser && !currentUser.email) {
        console.log('User without email detected in render - showing auth page');
        currentPage = 'auth';
        currentUser = null;
      }
      
      if (!currentUser) {
        root.innerHTML = renderAuthPage();
        attachAuthListeners();
      } else {
        // Handle different pages
        if (currentPage === 'poker-setup') {
          root.innerHTML = renderPokerSetup();
          attachPokerSetupListeners();
          return;
        }
        if (currentPage === 'poker-lobby' || currentPage === 'strategy-lobby' || currentPage === 'bullshit-lobby' || currentPage === 'spades-lobby') {
          root.innerHTML = renderMainLayout();
          attachLobbyListeners();
        } else if (currentPage === 'waiting-room') {
          root.innerHTML = renderMainLayout();
          attachWaitingRoomListeners();
        } else {
          root.innerHTML = renderMainLayout();
          if (currentPage === 'profile') {
            attachProfileListeners();
          } else if (currentPage === 'menu') {
            attachHomeListeners();
          } else if (currentPage === 'game') {
            if (gameData?.type === GAME_TYPES.STRATEGY) {
              attachStrategyListeners();
            } else if (gameData?.type === GAME_TYPES.POKER) {
              attachPokerListeners();
            } else if (gameData?.type === GAME_TYPES.BULLSHIT) {
              attachBullshitListeners();
            } else if (gameData?.type === GAME_TYPES.SPADES) {
              attachSpadesListeners();
            }
          }
        }
            }
          }
        
      
    

    function renderMainLayout() {
      return `
        <div class="min-h-screen bg-[#0a0a0c] text-slate-100 font-sans selection:bg-blue-500/30">
          <nav class="border-b border-white/5 p-3 flex justify-between items-center bg-black/40 backdrop-blur-xl sticky top-0 z-50">
            <div class="flex items-center gap-3 cursor-pointer group" id="home-btn">
              <div class="bg-blue-600 p-2 rounded-xl text-white group-hover:rotate-12 transition-transform">${icons.trophy}</div>
              <h1 class="text-lg font-black uppercase italic tracking-tighter text-white">Retro Royal</h1>
            </div>
            <div class="flex items-center gap-3">
              <button id="profile-btn" class="flex items-center gap-2 p-1.5 pr-3 rounded-xl transition-all border border-white/5 ${currentPage === 'profile' ? 'bg-blue-600 border-blue-500' : 'bg-white/5 hover:bg-white/10'}">
                <div class="w-7 h-7 bg-blue-600/20 rounded-lg flex items-center justify-center text-sm">
                  ${userStats.avatar || 'üë§'}
                </div>
                <span class="text-xs font-bold text-slate-300 hidden sm:inline uppercase">${currentUser.displayName || 'Operator'}</span>
              </button>
              <button id="signout-btn" class="p-2 hover:bg-red-500/20 text-red-500 rounded-xl transition-all border border-red-500/20 flex items-center gap-2"><span>üö™</span><span>Logout</span></button>
            </div>
          </nav>
          <main class="max-w-7xl mx-auto p-3 md:p-4">
            ${currentPage === 'profile' ? renderProfilePage() : ''}
            ${currentPage === 'menu' ? renderHomePage() : ''}
            ${currentPage === 'poker-lobby' || currentPage === 'strategy-lobby' || currentPage === 'bullshit-lobby' || currentPage === 'spades-lobby' ? renderLobbyPage() : ''}
            ${currentPage === 'waiting-room' ? renderWaitingRoom() : ''}
            ${currentPage === 'game' && gameData ? renderGamePage() : ''}
          </main>
          
          <!-- Avatar Selection Modal -->
          <div id="avatar-modal" class="hidden fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div class="bg-slate-900 border border-white/10 rounded-3xl p-6 max-w-lg w-full">
              <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-black uppercase italic text-white">Select Avatar</h3>
                <button id="close-avatar-modal" class="text-slate-400 hover:text-white transition-colors text-2xl">&times;</button>
              </div>
              <div class="grid grid-cols-7 gap-3 mb-4">
                ${AVATARS.map(avatar => `
                  <button class="avatar-option w-12 h-12 bg-slate-800 hover:bg-blue-600/20 border-2 ${userStats.avatar === avatar ? 'border-blue-500' : 'border-white/10'} rounded-xl flex items-center justify-center text-2xl transition-all hover:scale-110" data-avatar="${avatar}">
                    ${avatar}
                  </button>
                `).join('')}
              </div>
              <button id="save-avatar-btn" class="w-full py-3 bg-blue-600 hover:bg-blue-500 rounded-xl font-black uppercase text-white transition-all">
                Save Avatar
              </button>
            </div>
          </div>
        </div>
      `;
    }

    function renderAuthPage() {
      return `
        <div class="min-h-screen bg-black text-white">
          <div class="min-h-[80vh] flex items-center justify-center p-4">
            <div class="w-full max-w-md bg-slate-900 border border-white/10 rounded-[2.5rem] p-8 md:p-10 shadow-2xl">
              <div class="text-center mb-10">
                <div class="inline-flex p-4 bg-blue-600/20 rounded-2xl mb-4">
                  ${icons.shield}
                </div>
                <h2 class="text-3xl font-black uppercase italic tracking-tighter text-white">System Access</h2>
              </div>
              <form id="auth-form" class="space-y-5">
                <div id="displayname-field" class="space-y-2 hidden">
                  <label class="text-[10px] font-black uppercase tracking-widest text-slate-500 ml-1">Callsign</label>
                  <input type="text" id="displayName" placeholder="OPERATOR" class="w-full bg-black border border-white/10 rounded-2xl px-4 py-4 focus:outline-none focus:border-blue-500 transition-colors uppercase font-bold text-white" />
                </div>
                <div class="space-y-2">
                  <label class="text-[10px] font-black uppercase tracking-widest text-slate-500 ml-1">Email</label>
                  <input type="email" required id="email" placeholder="user@retro.io" class="w-full bg-black border border-white/10 rounded-2xl px-4 py-4 focus:outline-none focus:border-blue-500 transition-colors text-white" />
                </div>
                <div class="space-y-2">
                  <label class="text-[10px] font-black uppercase tracking-widest text-slate-500 ml-1">Password</label>
                  <input type="password" required id="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" class="w-full bg-black border border-white/10 rounded-2xl px-4 py-4 focus:outline-none focus:border-blue-500 transition-colors text-white" />
                </div>
                <div id="auth-error" class="hidden p-4 bg-red-500/10 border border-red-500/20 rounded-xl text-red-400 text-xs font-bold text-center"></div>
                <div id="auth-success" class="hidden p-4 bg-green-500/10 border border-green-500/20 rounded-xl text-green-400 text-xs font-bold text-center"></div>
                <button type="submit" id="auth-submit" class="w-full py-5 bg-blue-600 hover:bg-blue-500 disabled:opacity-50 rounded-2xl font-black uppercase italic tracking-widest shadow-xl shadow-blue-900/30 transition-all active:scale-95 text-white">
                  Infiltrate
                </button>
              </form>
              
              <div class="my-6 flex items-center gap-3">
                <div class="flex-1 h-px bg-white/10"></div>
                <span class="text-xs font-black text-slate-600 uppercase">Or</span>
                <div class="flex-1 h-px bg-white/10"></div>
              </div>
              
              <button id="google-signin-btn" class="w-full py-4 bg-white hover:bg-slate-100 rounded-2xl font-black uppercase text-slate-900 flex items-center justify-center gap-3 transition-all active:scale-95 border border-white/20">
                <svg class="w-5 h-5" viewBox="0 0 24 24">
                  <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                  <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                  <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                  <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                </svg>
                <span class="text-sm tracking-wide">Continue with Google</span>
              </button>
              
              <div class="mt-6 text-center space-y-3">
                <button id="forgot-password-btn" class="text-xs font-bold text-slate-500 hover:text-blue-400 transition-colors block mx-auto">
                  Forgot Password?
                </button>
                <button id="toggle-mode" class="text-xs font-bold text-slate-500 hover:text-blue-400 transition-colors">
                  NEW RECRUIT? REGISTER HERE
                </button>
              </div>
            </div>
          </div>
          
          <!-- Forgot Password Modal -->
          <div id="forgot-password-modal" class="hidden fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div class="bg-slate-900 border border-white/10 rounded-3xl p-8 max-w-md w-full">
              <h3 class="text-2xl font-black uppercase italic text-white mb-2">Reset Password</h3>
              <p class="text-sm text-slate-400 mb-4">Enter your email address and we'll send you a password reset link.</p>
              
              <div class="p-3 bg-yellow-500/10 border border-yellow-500/20 rounded-xl mb-4">
                <p class="text-xs text-yellow-400 font-bold">üí° Tip: Check your spam folder if you don't see the email in your inbox!</p>
              </div>
              
              <div class="space-y-4">
                <div class="space-y-2">
                  <label class="text-[10px] font-black uppercase tracking-widest text-slate-500 ml-1">Email</label>
                  <input type="email" id="reset-email" placeholder="user@retro.io" class="w-full bg-black border border-white/10 rounded-2xl px-4 py-4 focus:outline-none focus:border-blue-500 transition-colors text-white" />
                </div>
                
                <div id="reset-error" class="hidden p-4 bg-red-500/10 border border-red-500/20 rounded-xl text-red-400 text-xs font-bold text-center"></div>
                <div id="reset-success" class="hidden p-4 bg-green-500/10 border border-green-500/20 rounded-xl text-green-400 text-xs font-bold text-center"></div>
                
                <div class="flex gap-3">
                  <button id="cancel-reset-btn" class="flex-1 py-3 bg-white/5 hover:bg-white/10 border border-white/10 rounded-xl font-black uppercase text-white transition-all">
                    Cancel
                  </button>
                  <button id="send-reset-btn" class="flex-1 py-3 bg-blue-600 hover:bg-blue-500 rounded-xl font-black uppercase text-white transition-all">
                    Send Reset Link
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function renderProfilePage() {
      // Safety check - if no valid email, shouldn't be here
      if (!currentUser || !currentUser.email) {
        currentPage = 'auth';
        render();
        return '';
      }
      
      return `
        <div class="max-w-6xl mx-auto py-4 animate-in">
          <button id="back-btn" class="flex items-center gap-2 text-slate-500 hover:text-white mb-4 group transition-colors">
            ${icons.arrowLeft}
            <span class="text-[10px] font-black uppercase tracking-widest">Return to Terminal</span>
          </button>
          
          <div class="grid md:grid-cols-12 gap-4">
            <!-- Left Column - Profile Card -->
            <div class="md:col-span-3 bg-slate-900 border border-white/10 rounded-3xl p-6 flex flex-col items-center text-center h-fit">
              <div class="relative group mb-4">
                <div class="w-24 h-24 bg-blue-600/20 rounded-full border-2 border-blue-500/30 flex items-center justify-center overflow-hidden">
                  <div class="text-5xl">${userStats.avatar || 'üë§'}</div>
                </div>
                <button id="change-avatar-btn" class="absolute bottom-0 right-0 p-1.5 bg-blue-600 rounded-full border-2 border-slate-900 text-white hover:scale-110 transition-transform text-xs">
                  ${icons.camera}
                </button>
              </div>
              <h3 class="text-xl font-black uppercase italic text-white tracking-tighter leading-tight">${currentUser.displayName || 'Operator'}</h3>
              <p class="text-[9px] font-black text-slate-500 uppercase tracking-[0.2em] mt-1 mb-4">Registered Identity</p>
              
              <div class="w-full space-y-2 mb-4">
                <div class="p-3 bg-black/40 rounded-xl border border-white/5 text-left">
                  <p class="text-[8px] font-black text-slate-600 uppercase tracking-widest mb-0.5">Email Hash</p>
                  <p class="text-[10px] font-bold text-slate-300 truncate">${currentUser.email}</p>
                </div>
                <div class="p-3 bg-black/40 rounded-xl border border-white/5 text-left">
                  <p class="text-[8px] font-black text-slate-600 uppercase tracking-widest mb-0.5">User ID</p>
                  <p class="text-[10px] font-bold text-slate-300 truncate">${currentUser.uid}</p>
                </div>
                <div class="p-3 bg-black/40 rounded-xl border border-white/5 text-left">
                  <p class="text-[8px] font-black text-slate-600 uppercase tracking-widest mb-0.5">Auth Provider</p>
                  <p class="text-[10px] font-bold text-slate-300">${currentUser.providerData?.[0]?.providerId || 'password'}</p>
                </div>
              </div>
              
              <button id="profile-signout-btn" class="w-full py-3 bg-red-500/10 hover:bg-red-500/20 border border-red-500/20 text-red-500 rounded-xl font-black uppercase italic tracking-widest text-[9px] transition-all">Sign Out</button>
            </div>
            
            <!-- Middle Column - Stats -->
            <div class="md:col-span-5 space-y-4">
              <div class="bg-slate-900 border border-white/10 rounded-3xl p-6">
                <h4 class="text-sm font-black uppercase italic text-white tracking-widest mb-4 flex items-center gap-2">
                  ${icons.activity} <span>Metrics</span>
                </h4>
                <div class="grid grid-cols-2 gap-3">
                  <div class="p-4 bg-black/40 border border-white/5 rounded-2xl">
                    <div class="flex justify-between items-start mb-1">
                      <p class="text-[8px] font-black text-slate-600 uppercase tracking-widest">Wins</p>
                      <div class="text-xs">${icons.trophy}</div>
                    </div>
                    <p class="text-xl font-black italic tracking-tighter text-white">${userStats.totalWins}</p>
                    <div class="mt-1 flex gap-1 text-[8px] text-slate-500">
                      <span>P:${userStats.pokerWins}</span>
                      <span>‚Ä¢</span>
                      <span>S:${userStats.strategyWins}</span>
                    </div>
                  </div>
                  <div class="p-4 bg-black/40 border border-white/5 rounded-2xl">
                    <div class="flex justify-between items-start mb-1">
                      <p class="text-[8px] font-black text-slate-600 uppercase tracking-widest">Credits</p>
                      <div class="text-xs">${icons.coins}</div>
                    </div>
                    <p class="text-xl font-black italic tracking-tighter text-white">$${gameData?.playerStates?.[currentUser.uid]?.chips || userStats.totalChips}</p>
                  </div>
                  <div class="p-4 bg-black/40 border border-white/5 rounded-2xl">
                    <div class="flex justify-between items-start mb-1">
                      <p class="text-[8px] font-black text-slate-600 uppercase tracking-widest">Nodes</p>
                      <div class="text-xs">${icons.target}</div>
                    </div>
                    <p class="text-xl font-black italic tracking-tighter text-white">${userStats.nodesSecured}</p>
                  </div>
                  <div class="p-4 bg-black/40 border border-white/5 rounded-2xl cursor-pointer hover:border-blue-500/30 transition-all" id="rank-info-btn">
                    <div class="flex justify-between items-start mb-1">
                      <p class="text-[8px] font-black text-slate-600 uppercase tracking-widest">Rank</p>
                      <div class="text-lg">${getRankInfo(userStats.totalWins).icon}</div>
                    </div>
                    <p class="text-xl font-black italic tracking-tighter" style="color: ${getRankInfo(userStats.totalWins).color}">${getRank(userStats.totalWins)}</p>
                    <div class="mt-1 text-[8px] text-slate-500 hover:text-blue-400 transition-colors flex items-center gap-1">
                      <span class="text-[10px]">${icons.info}</span> <span>Details</span>
                    </div>
                  </div>
                </div>
                
                <!-- Compact Rank Progress -->
                ${getRankInfo(userStats.totalWins).name !== 'Legend' ? `
                  <div class="mt-4 p-4 bg-gradient-to-br from-blue-600/10 to-purple-600/10 border border-blue-500/20 rounded-2xl">
                    <div class="flex justify-between items-center mb-2">
                      <p class="text-[9px] font-black uppercase text-white">Next: ${getNextRank(userStats.totalWins)?.name || 'Max'}</p>
                      <p class="text-[9px] font-black text-blue-400">${userStats.totalWins}/${getNextRank(userStats.totalWins)?.wins || userStats.totalWins}</p>
                    </div>
                    <div class="w-full h-2 bg-black/40 rounded-full overflow-hidden border border-white/10">
                      <div class="h-full bg-gradient-to-r from-blue-500 to-purple-500 rounded-full transition-all duration-1000" style="width: ${getRankProgress(userStats.totalWins)}%"></div>
                    </div>
                  </div>
                ` : `
                  <div class="mt-4 p-4 bg-gradient-to-br from-yellow-600/20 to-orange-600/20 border border-yellow-500/30 rounded-2xl text-center">
                    <div class="text-2xl mb-1">‚≠ê</div>
                    <p class="text-xs font-black uppercase italic text-yellow-400">Legendary Status</p>
                  </div>
                `}
              </div>
            </div>
            
            <!-- Right Column - Settings -->
            <div class="md:col-span-4 space-y-4">
              <div class="bg-slate-900 border border-white/10 rounded-3xl p-6">
                <h4 class="text-sm font-black uppercase italic text-white tracking-widest mb-4 flex items-center gap-2">
                  ${icons.settings} <span>Config</span>
                </h4>
                <div class="space-y-3">
                  <div class="space-y-1">
                    <label class="text-[9px] font-black uppercase text-slate-500 tracking-widest ml-1">Callsign</label>
                    <input type="text" id="profile-name" value="${currentUser.displayName || ''}" class="w-full bg-black/60 border border-white/10 rounded-xl px-4 py-2.5 focus:border-blue-500 outline-none font-bold uppercase text-white text-sm" />
                  </div>
                  <button id="update-profile-btn" class="w-full py-2.5 bg-blue-600 hover:bg-blue-500 rounded-xl font-black flex items-center justify-center gap-2 tracking-widest text-[9px] uppercase italic transition-all text-white">
                    ${icons.save} Apply
                  </button>
                  
                  <div class="p-4 bg-blue-600/5 border border-blue-500/10 rounded-2xl">
                    <div class="flex justify-between items-center">
                      <div>
                        <h5 class="font-black text-[10px] uppercase text-blue-400">Credit Repair</h5>
                        <p class="text-[8px] text-slate-500 italic mt-0.5 font-bold">Inject $2000</p>
                      </div>
                      <button id="topup-btn" class="px-4 py-2 bg-blue-600 hover:bg-blue-500 rounded-xl transition-all font-black text-[9px] uppercase italic text-white">Execute</button>
                    </div>
                  </div>
                  
                  <button id="delete-account-btn" class="w-full py-2.5 bg-red-500/10 hover:bg-red-500/20 text-red-500 border border-red-500/20 rounded-xl font-black flex items-center justify-center gap-2 text-[9px] tracking-widest uppercase italic">
                    ${icons.trash} Purge Identity
                  </button>
                </div>
                <div id="profile-status" class="mt-4 text-center text-blue-400 font-bold text-[10px] animate-pulse uppercase tracking-widest hidden"></div>
              </div>
            </div>
          </div>
          
          <div id="delete-confirm" class="fixed inset-0 bg-black/90 backdrop-blur-md z-[100] flex items-center justify-center p-4 hidden">
            <div class="max-w-sm w-full bg-slate-900 border border-red-500/50 rounded-[2.5rem] p-8 text-center space-y-6 shadow-2xl">
              <div class="text-red-500 flex justify-center">${icons.alertTriangle}</div>
              <h3 class="text-xl font-black uppercase italic text-white">Critical Confirmation</h3>
              <p class="text-slate-400 text-xs font-bold leading-relaxed">This will permanently erase all data associated with this node. Proceed?</p>
              <div class="space-y-3 pt-4">
                <button id="confirm-delete-btn" class="w-full py-4 bg-red-600 hover:bg-red-500 rounded-2xl font-black text-white uppercase italic tracking-widest text-xs">Confirm Purge</button>
                <button id="cancel-delete-btn" class="w-full py-4 bg-white/5 hover:bg-white/10 rounded-2xl font-black text-slate-400 uppercase italic tracking-widest text-xs">Cancel</button>
              </div>
            </div>
          </div>
          
          <!-- Rank System Info Modal -->
          <div id="rank-modal" class="fixed inset-0 bg-black/90 backdrop-blur-md z-[100] flex items-center justify-center p-4 hidden overflow-y-auto">
            <div class="max-w-5xl w-full bg-slate-900 border border-blue-500/30 rounded-3xl p-6 shadow-2xl my-4 max-h-[90vh] overflow-y-auto">
              <div class="flex justify-between items-start mb-6">
                <div>
                  <h3 class="text-2xl font-black uppercase italic text-white tracking-tighter">Rank System</h3>
                  <p class="text-[9px] text-slate-500 uppercase tracking-widest mt-1">Progression & Benefits</p>
                </div>
                <button id="close-rank-modal" class="p-2 bg-white/5 hover:bg-white/10 rounded-xl transition-all">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-slate-400">
                    <path d="M18 6L6 18M6 6l12 12"></path>
                  </svg>
                </button>
              </div>
              
              <div class="grid md:grid-cols-2 gap-3">
                ${[
                  { name: 'Recruit', minWins: 0, maxWins: 4, color: '#64748b', icon: 'üî∞', description: 'New operator entering the neural network', bonus: 'Welcome Package: 2000 Credits' },
                  { name: 'Specialist', minWins: 5, maxWins: 9, color: '#3b82f6', icon: '‚ö°', description: 'Proven tactical capability', bonus: '+10% starting energy in Strategy' },
                  { name: 'Vanguard', minWins: 10, maxWins: 24, color: '#8b5cf6', icon: 'üéØ', description: 'Elite operative with command authority', bonus: '+200 starting chips in Poker' },
                  { name: 'Veteran', minWins: 25, maxWins: 49, color: '#ec4899', icon: 'üíé', description: 'Seasoned warrior of countless victories', bonus: '+2 starting nodes in Strategy' },
                  { name: 'Master', minWins: 50, maxWins: 99, color: '#f59e0b', icon: 'üëë', description: 'Master strategist dominating the battlefield', bonus: '+500 chips & +15% energy' },
                  { name: 'Legend', minWins: 100, maxWins: 999999, color: '#eab308', icon: '‚≠ê', description: 'Legendary status achieved', bonus: 'All bonuses + Special cosmetics' }
                ].map(rank => {
                  const isCurrentRank = userStats.totalWins >= rank.minWins && userStats.totalWins <= rank.maxWins;
                  const isUnlocked = userStats.totalWins >= rank.minWins;
                  
                  return `
                    <div class="p-4 rounded-2xl border-2 transition-all ${
                      isCurrentRank 
                        ? 'bg-gradient-to-br from-blue-600/20 to-purple-600/20 border-blue-500/50' 
                        : isUnlocked
                          ? 'bg-black/40 border-white/10'
                          : 'bg-black/20 border-white/5 opacity-60'
                    }">
                      <div class="flex items-start gap-3">
                        <div class="text-2xl ${isUnlocked ? '' : 'grayscale opacity-50'}">${rank.icon}</div>
                        <div class="flex-1 min-w-0">
                          <div class="flex items-center gap-2 mb-1 flex-wrap">
                            <h4 class="text-base font-black uppercase italic tracking-tighter" style="color: ${isUnlocked ? rank.color : '#64748b'}">${rank.name}</h4>
                            ${isCurrentRank ? '<span class="px-2 py-0.5 bg-blue-600 text-white text-[8px] font-black uppercase rounded-full">Current</span>' : ''}
                          </div>
                          <p class="text-[10px] text-slate-400 mb-2">${rank.description}</p>
                          <div class="flex items-start gap-2 p-2 bg-black/40 rounded-lg border border-white/5">
                            <div class="text-emerald-500 text-xs">${icons.zap}</div>
                            <div class="flex-1 min-w-0">
                              <p class="text-[8px] font-black text-slate-600 uppercase tracking-widest mb-0.5">Bonus</p>
                              <p class="text-[10px] font-bold text-white">${rank.bonus}</p>
                            </div>
                          </div>
                        </div>
                        <div class="text-right">
                          <p class="text-[8px] font-black text-slate-600 uppercase tracking-widest">Wins</p>
                          <p class="text-lg font-black italic tracking-tighter" style="color: ${isUnlocked ? rank.color : '#64748b'}">${rank.minWins}${rank.maxWins < 999999 ? `-${rank.maxWins}` : '+'}</p>
                        </div>
                      </div>
                    </div>
                  `;
                }).join('')}
              </div>
              
              <div class="mt-4 p-4 bg-gradient-to-r from-blue-600/10 to-purple-600/10 border border-blue-500/20 rounded-2xl">
                <div class="flex items-start gap-3">
                  <div class="text-blue-500 text-sm">${icons.info}</div>
                  <div>
                    <h5 class="text-xs font-black uppercase text-white mb-2">How Ranking Works</h5>
                    <ul class="space-y-1 text-[10px] text-slate-400">
                      <li class="flex gap-2"><span class="text-blue-500">‚Ä¢</span><span>Win games in Poker and Strategy to increase total wins</span></li>
                      <li class="flex gap-2"><span class="text-blue-500">‚Ä¢</span><span>Each rank unlocks permanent bonuses for all future games</span></li>
                      <li class="flex gap-2"><span class="text-blue-500">‚Ä¢</span><span>Progress saves in the cloud and persists across sessions</span></li>
                    </ul>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function renderHomePage() {
      return `
        <div class="grid md:grid-cols-2 gap-6 py-6 max-w-5xl mx-auto">
          <div class="bg-slate-900 border border-white/10 rounded-3xl p-6 space-y-6 hover:border-blue-500/50 transition-all group">
            <div class="p-3 bg-white/5 rounded-xl w-fit group-hover:bg-blue-600/10 transition-colors">
              ${icons.dice}
            </div>
            <div>
              <h3 class="text-2xl font-black uppercase italic text-white">Royal Hold'em</h3>
              <p class="text-slate-400 font-medium mt-1 text-sm">No-limit neural poker simulation</p>
            </div>
            <div class="grid grid-cols-2 gap-3">
              <button id="poker-solo-btn" class="py-3 bg-white/5 hover:bg-white/10 rounded-xl font-black uppercase italic tracking-widest text-[10px] border border-white/5 text-white transition-all">Solo Link</button>
              <button id="poker-multi-btn" class="py-3 bg-blue-600 hover:bg-blue-500 rounded-xl font-black uppercase italic tracking-widest text-[10px] shadow-xl shadow-blue-900/30 text-white transition-all">Online Node</button>
            </div>
          </div>
          
          <div class="bg-slate-900 border border-white/10 rounded-3xl p-6 space-y-6 hover:border-red-500/50 transition-all group">
            <div class="p-3 bg-white/5 rounded-xl w-fit group-hover:bg-red-600/10 transition-colors">
              ${icons.globe}
            </div>
            <div>
              <h3 class="text-2xl font-black uppercase italic text-white">Global Takeover</h3>
              <p class="text-slate-400 font-medium mt-1 text-sm">Tactical node-based conquest</p>
            </div>
            <div class="grid grid-cols-2 gap-3">
              <button id="strategy-solo-btn" class="py-3 bg-white/5 hover:bg-white/10 rounded-xl font-black uppercase italic tracking-widest text-[10px] border border-white/5 text-white transition-all">Solo Link</button>
              <button id="strategy-multi-btn" class="py-3 bg-red-600 hover:bg-red-500 rounded-xl font-black uppercase italic tracking-widest text-[10px] shadow-xl shadow-red-900/30 text-white transition-all">Online Node</button>
            </div>
          </div>
          
          <div class="bg-slate-900 border border-white/10 rounded-3xl p-6 space-y-6 hover:border-yellow-500/50 transition-all group">
            <div class="p-3 bg-white/5 rounded-xl w-fit group-hover:bg-yellow-600/10 transition-colors">
              üÉè
            </div>
            <div>
              <h3 class="text-2xl font-black uppercase italic text-white">Bullshit</h3>
              <p class="text-slate-400 font-medium mt-1 text-sm">Bluff your way to victory</p>
            </div>
            <div class="grid grid-cols-2 gap-3">
              <button id="bullshit-solo-btn" class="py-3 bg-white/5 hover:bg-white/10 rounded-xl font-black uppercase italic tracking-widest text-[10px] border border-white/5 text-white transition-all">Solo Link</button>
              <button id="bullshit-multi-btn" class="py-3 bg-yellow-600 hover:bg-yellow-500 rounded-xl font-black uppercase italic tracking-widest text-[10px] shadow-xl shadow-yellow-900/30 text-white transition-all">Online Node</button>
            </div>
          </div>
          
          <div class="bg-slate-900 border border-white/10 rounded-3xl p-6 space-y-6 hover:border-green-500/50 transition-all group">
            <div class="p-3 bg-white/5 rounded-xl w-fit group-hover:bg-green-600/10 transition-colors">
              ‚ô†Ô∏è
            </div>
            <div>
              <h3 class="text-2xl font-black uppercase italic text-white">Spades</h3>
              <p class="text-slate-400 font-medium mt-1 text-sm">Partnership trick-taking classic</p>
            </div>
            <div class="grid grid-cols-2 gap-3">
              <button id="spades-solo-btn" class="py-3 bg-white/5 hover:bg-white/10 rounded-xl font-black uppercase italic tracking-widest text-[10px] border border-white/5 text-white transition-all">Solo Link</button>
              <button id="spades-multi-btn" class="py-3 bg-green-600 hover:bg-green-500 rounded-xl font-black uppercase italic tracking-widest text-[10px] shadow-xl shadow-green-900/30 text-white transition-all">Online Node</button>
            </div>
          </div>
        </div>
      `;
    }
    
    function renderPokerSetup() {
      return `
        <div class="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 p-4">
          <div class="max-w-2xl mx-auto">
            <div class="bg-slate-800/50 backdrop-blur-xl p-8 rounded-2xl border border-purple-500/20 shadow-2xl">
              <h2 class="text-3xl font-bold text-white mb-6">Poker Setup</h2>
              
              <div class="space-y-6">
                <div>
                  <label class="block text-purple-300 mb-3 text-lg">Number of AI Players</label>
                  <div class="flex gap-3">
                    ${[1, 2, 3, 4].map(count => `
                      <button
                        class="ai-count-btn flex-1 py-4 ${aiPlayerCount === count ? 'bg-gradient-to-r from-purple-600 to-pink-600' : 'bg-slate-700/50 hover:bg-slate-600/50'} text-white font-semibold rounded-lg transition-all duration-200 border ${aiPlayerCount === count ? 'border-purple-400' : 'border-purple-500/30'}"
                        data-count="${count}"
                      >
                        ${count} AI
                      </button>
                    `).join('')}
                  </div>
                </div>
                
                <div class="bg-slate-900/50 p-4 rounded-lg border border-purple-500/20">
                  <h3 class="text-purple-300 font-semibold mb-2">Game Info:</h3>
                  <ul class="text-slate-300 text-sm space-y-1">
                    <li>‚Ä¢ Starting chips: 1,000 per player</li>
                    <li>‚Ä¢ Minimum bet: 20 chips</li>
                    <li>‚Ä¢ Enhanced AI with strategic betting</li>
                    <li>‚Ä¢ Game continues until one player remains</li>
                  </ul>
                </div>
                
                <div class="flex gap-3">
                  <button
                    id="back-to-menu-btn"
                    class="flex-1 py-3 bg-slate-700/50 hover:bg-slate-600/50 text-purple-300 rounded-lg transition-all duration-200 border border-purple-500/30"
                  >
                    ‚Üê Back
                  </button>
                  <button
                    id="start-poker-btn"
                    class="flex-1 py-3 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-500 hover:to-pink-500 text-white font-semibold rounded-lg transition-all duration-200 shadow-lg hover:shadow-purple-500/50"
                  >
                    Start Game
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function renderLobbyPage() {
      let selectedGameType = GAME_TYPES.STRATEGY;
      let gameTitle = 'Global Takeover';
      
      if (currentPage === 'poker-lobby') {
        selectedGameType = GAME_TYPES.POKER;
        gameTitle = 'Royal Hold\'em';
      } else if (currentPage === 'strategy-lobby') {
        selectedGameType = GAME_TYPES.STRATEGY;
        gameTitle = 'Global Takeover';
      } else if (currentPage === 'bullshit-lobby') {
        selectedGameType = GAME_TYPES.BULLSHIT;
        gameTitle = 'Bullshit';
      } else if (currentPage === 'spades-lobby') {
        selectedGameType = GAME_TYPES.SPADES;
        gameTitle = 'Spades';
      }
      
      return `
        <div class="max-w-5xl mx-auto py-4">
          <button id="lobby-back-btn" class="flex items-center gap-2 text-slate-500 hover:text-white mb-4 transition-colors">
            ${icons.arrowLeft}
            <span class="text-[10px] font-black uppercase tracking-widest">Back to Menu</span>
          </button>
          
          <div class="bg-slate-900 border border-white/10 rounded-3xl p-6">
            <div class="flex justify-between items-center mb-6">
              <div>
                <h2 class="text-2xl font-black uppercase italic text-white">${gameTitle} Lobbies</h2>
                <p class="text-xs text-slate-500 uppercase tracking-widest mt-1">Multiplayer Matchmaking</p>
              </div>
              <button id="create-lobby-btn" class="px-6 py-3 bg-blue-600 hover:bg-blue-500 rounded-xl font-black uppercase text-[10px] italic text-white transition-all">
                Create Lobby
              </button>
            </div>
            
            <!-- Search Bar -->
            <div class="mb-6">
              <div class="relative">
                <div class="absolute left-4 top-1/2 -translate-y-1/2 text-slate-500">
                  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"></circle>
                    <path d="m21 21-4.35-4.35"></path>
                  </svg>
                </div>
                <input 
                  type="text" 
                  id="lobby-search" 
                  placeholder="Search by lobby ID or host name..." 
                  class="w-full bg-black/60 border border-white/10 rounded-xl px-12 py-3 focus:border-blue-500 outline-none font-medium text-white text-sm placeholder:text-slate-600"
                />
                <button id="refresh-lobbies-btn" class="absolute right-2 top-1/2 -translate-y-1/2 p-2 bg-white/5 hover:bg-white/10 rounded-lg transition-all">
                  ${icons.refresh}
                </button>
              </div>
            </div>
            
            <div id="lobbies-container" class="space-y-3">
              ${availableLobbies.length === 0 ? `
                <div class="text-center py-12">
                  <div class="text-slate-600 mb-3">${icons.globe}</div>
                  <p class="text-slate-500 font-bold text-sm">No active lobbies</p>
                  <p class="text-slate-600 text-xs mt-1">Create one to get started!</p>
                </div>
              ` : availableLobbies.map(lobby => `
                <div class="lobby-item p-4 bg-black/40 border border-white/10 rounded-2xl hover:border-blue-500/30 transition-all" data-lobby-id="${lobby.id}" data-host-name="${lobby.hostName.toLowerCase()}">
                  <div class="flex justify-between items-center">
                    <div class="flex-1">
                      <div class="flex items-center gap-3 mb-2">
                        <h3 class="text-lg font-black uppercase italic text-white">${lobby.hostName}'s Game</h3>
                        <span class="px-2 py-1 bg-blue-600/20 text-blue-400 text-[9px] font-black uppercase rounded-full">
                          ${lobby.players.length}/${lobby.maxPlayers} Players
                        </span>
                      </div>
                      <div class="flex gap-4 text-[10px] text-slate-500">
                        <span>ID: <span class="lobby-id">${lobby.id}</span></span>
                        <span>‚Ä¢</span>
                        <span>Created ${new Date(lobby.createdAt).toLocaleTimeString()}</span>
                      </div>
                    </div>
                    <button data-lobby-id="${lobby.id}" class="join-lobby-btn px-6 py-3 ${lobby.players.length >= lobby.maxPlayers ? 'bg-slate-700 cursor-not-allowed' : 'bg-emerald-600 hover:bg-emerald-500'} rounded-xl font-black uppercase text-[10px] text-white transition-all" ${lobby.players.length >= lobby.maxPlayers ? 'disabled' : ''}>
                      ${lobby.players.length >= lobby.maxPlayers ? 'Full' : 'Join'}
                    </button>
                  </div>
                  <div class="mt-3 flex gap-2">
                    ${lobby.players.map(p => `
                      <div class="px-3 py-1 bg-white/5 rounded-lg border border-white/5">
                        <span class="text-[10px] font-bold text-slate-300">${p.name}</span>
                      </div>
                    `).join('')}
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        </div>
      `;
    }

    function renderWaitingRoom() {
      if (!gameData) return '';
      
      const isHost = gameData.hostId === currentUser.uid;
      let gameTitle = 'Global Takeover';
      
      // In waiting room, gameData is the lobby data which uses 'gameType', not 'type'
      const gameType = gameData.gameType || gameData.type;
      
      if (gameType === GAME_TYPES.POKER) {
        gameTitle = 'Royal Hold\'em';
      } else if (gameType === GAME_TYPES.STRATEGY) {
        gameTitle = 'Global Takeover';
      } else if (gameType === GAME_TYPES.BULLSHIT) {
        gameTitle = 'Bullshit';
      } else if (gameType === GAME_TYPES.SPADES) {
        gameTitle = 'Spades';
      }
      
      return `
        <div class="max-w-4xl mx-auto py-4">
          <button id="leave-lobby-btn" class="flex items-center gap-2 text-slate-500 hover:text-white mb-4 transition-colors">
            ${icons.arrowLeft}
            <span class="text-[10px] font-black uppercase tracking-widest">Leave Lobby</span>
          </button>
          
          <div class="bg-slate-900 border border-white/10 rounded-3xl p-8">
            <div class="text-center mb-8">
              <h2 class="text-3xl font-black uppercase italic text-white mb-2">${gameTitle}</h2>
              <p class="text-sm text-slate-500 uppercase tracking-widest">Waiting Room</p>
              <div class="mt-4 px-4 py-2 bg-blue-600/20 border border-blue-500/30 rounded-xl inline-block">
                <p class="text-xs font-black text-blue-400">LOBBY CODE: ${gameData.id}</p>
              </div>
            </div>
            
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
              ${gameData.players.map(player => `
                <div class="p-6 bg-black/40 border border-white/10 rounded-2xl text-center">
                  <div class="w-16 h-16 bg-blue-600/20 rounded-full mx-auto mb-3 flex items-center justify-center text-3xl relative">
                    ${player.avatar || 'üë§'}
                    ${player.id === gameData.hostId ? '<div class="absolute -top-1 -right-1 text-xl">üëë</div>' : ''}
                  </div>
                  <p class="font-black uppercase text-white text-sm truncate">${player.name}</p>
                  <p class="text-[9px] text-slate-500 uppercase mt-1">${player.id === gameData.hostId ? 'Host' : 'Player'}</p>
                </div>
              `).join('')}
              ${Array(gameData.maxPlayers - gameData.players.length).fill(0).map((_, idx) => `
                <div class="p-6 bg-black/20 border border-white/5 rounded-2xl text-center border-dashed">
                  <div class="w-16 h-16 bg-white/5 rounded-full mx-auto mb-3 flex items-center justify-center text-2xl text-slate-600">
                    ${idx + gameData.players.length + 1}
                  </div>
                  <p class="font-black uppercase text-slate-600 text-sm">Empty</p>
                  <p class="text-[9px] text-slate-700 uppercase mt-1">Slot ${idx + gameData.players.length + 1}</p>
                </div>
              `).join('')}
            </div>
            
            ${isHost ? `
              <div class="space-y-3">
                <button id="start-game-btn" ${gameData.players.length < 2 ? 'disabled' : ''} class="w-full py-4 bg-emerald-600 hover:bg-emerald-500 disabled:bg-slate-700 disabled:cursor-not-allowed rounded-xl font-black uppercase text-sm text-white transition-all">
                  ${gameData.players.length < 2 ? 'Waiting for Players...' : 'Start Game'}
                </button>
                <p class="text-center text-xs text-slate-500">You are the host - start when ready</p>
              </div>
            ` : `
              <div class="text-center">
                <div class="animate-pulse text-blue-500 mb-3">${icons.refresh}</div>
                <p class="text-sm font-bold text-slate-400">Waiting for host to start...</p>
              </div>
            `}
          </div>
        </div>
      `;
    }

    function renderGamePage() {
      if (gameData.type === GAME_TYPES.STRATEGY) {
        return renderStrategyGame();
      } else if (gameData.type === GAME_TYPES.POKER) {
        return renderPokerGame();
      } else if (gameData.type === GAME_TYPES.BULLSHIT) {
        return renderBullshitGame();
      } else if (gameData.type === GAME_TYPES.SPADES) {
        return renderSpadesGame();
      }
      return '<div class="text-white">Loading game...</div>';
    }

    function renderStrategyGame() {
      // Check if multiplayer
      const isMulti = gameData.players && gameData.players.length > 1;
      const myPlayerId = currentUser.uid;
      const isMyTurn = isMulti ? gameData.currentTurn === myPlayerId : gameData.turn === 'player';
      const currentEnergy = isMulti ? (gameData.playerEnergy?.[myPlayerId] || 0) : gameData.energy;
      
      return `
        <div class="grid lg:grid-cols-4 gap-4 pb-4">
          <div class="lg:col-span-3 space-y-4">
            <div class="flex justify-between items-end">
              <div class="space-y-0.5">
                <h2 class="text-2xl font-black uppercase italic text-white">Global Takeover</h2>
                <p class="text-slate-500 font-bold text-[10px] uppercase">Grid Interface</p>
              </div>
              <div class="flex gap-3">
                <div class="bg-slate-900 border border-white/10 rounded-xl px-4 py-2 flex items-center gap-2">
                  ${icons.zap}
                  <span class="font-black text-lg text-white">${currentEnergy}</span>
                </div>
                <div class="bg-slate-900 border border-white/10 rounded-xl px-4 py-2 flex items-center gap-2">
                  ${icons.activity}
                  <span class="font-black text-[10px] uppercase italic ${isMyTurn ? 'text-blue-400' : 'text-white'}">
                    ${isMyTurn ? 'YOUR TURN' : 'Waiting...'}
                  </span>
                </div>
              </div>
            </div>
            
            <div class="aspect-square bg-slate-900 rounded-3xl p-3 border border-white/10 grid grid-cols-8 gap-1.5 relative overflow-hidden">
              ${gameData.grid.map((node, i) => {
                // Determine color based on owner
                let bgClass = 'bg-white/5 border-white/5';
                if (node.owner) {
                  if (isMulti) {
                    // Multiplayer: different colors for different players
                    const playerIndex = gameData.players.findIndex(p => p.id === node.owner);
                    const colors = [
                      'bg-blue-600/20 border-blue-500/50',
                      'bg-red-600/20 border-red-500/50', 
                      'bg-green-600/20 border-green-500/50',
                      'bg-yellow-600/20 border-yellow-500/50',
                      'bg-purple-600/20 border-purple-500/50',
                      'bg-pink-600/20 border-pink-500/50',
                      'bg-orange-600/20 border-orange-500/50',
                      'bg-cyan-600/20 border-cyan-500/50'
                    ];
                    bgClass = colors[playerIndex] || 'bg-gray-600/20 border-gray-500/50';
                  } else {
                    // Solo: player vs AI
                    bgClass = node.owner === 'player' ? 'bg-blue-600/20 border-blue-500/50' : 'bg-red-600/20 border-red-500/50';
                  }
                }
                
                const isMyNode = isMulti ? node.owner === myPlayerId : node.owner === 'player';
                
                return `
                  <div data-node-index="${i}" class="strategy-node rounded-lg border transition-all cursor-pointer flex items-center justify-center ${bgClass} ${selectedStrategyNode === i ? 'ring-2 ring-white scale-105 z-10' : ''}">
                    <div class="flex flex-col items-center">
                      ${node.owner ? `<div class="text-xs">${isMyNode ? icons.radio : icons.target}</div>` : ''}
                      <span class="text-[9px] font-black ${node.owner ? 'text-white' : 'text-slate-600'}">${node.strength}</span>
                    </div>
                  </div>
                `;
              }).join('')}
              
              ${(gameData.status === 'gameover' || gameData.status === 'victory') ? `
                <div class="absolute inset-0 bg-black/90 backdrop-blur-md flex flex-col items-center justify-center text-center p-8 z-50">
                  ${gameData.status === 'victory' ? 
                    `<div class="text-yellow-500 mb-4 text-6xl">${icons.trophy}</div>` : 
                    `<div class="text-red-500 mb-4 text-6xl">${icons.alertTriangle}</div>`
                  }
                  <h2 class="text-5xl font-black uppercase italic text-white">${gameData.status === 'victory' ? 'Victory' : 'Defeated'}</h2>
                  <button id="strategy-restart-btn" class="px-10 py-4 bg-blue-600 rounded-2xl font-black uppercase text-white mt-6">Return to Menu</button>
                </div>
              ` : ''}
            </div>
            
            <div class="flex justify-center gap-3">
              <button id="reinforce-btn" ${selectedStrategyNode === null || currentEnergy < 1 || !isMyTurn ? 'disabled' : ''} 
                class="px-6 py-3 bg-slate-900 border border-white/10 rounded-xl font-black uppercase text-[10px] text-white disabled:opacity-50">
                Reinforce (+1)
              </button>
              <button id="end-turn-btn" ${!isMyTurn ? 'disabled' : ''} 
                class="px-6 py-3 bg-blue-600 rounded-xl font-black uppercase text-[10px] text-white disabled:opacity-50">
                End Turn
              </button>
            </div>
            
            ${selectedStrategyNode !== null && gameData.grid[selectedStrategyNode]?.owner === (isMulti ? myPlayerId : 'player') && gameData.grid[selectedStrategyNode]?.strength > 1 ? `
              <div class="bg-slate-900 border border-white/10 rounded-2xl p-4">
                <p class="text-slate-400 font-black mb-3 uppercase text-[9px]">Transfer Troops</p>
                <div class="flex items-center gap-3">
                  <div class="flex-1">
                    <input type="range" id="transfer-slider" min="1" max="${gameData.grid[selectedStrategyNode].strength - 1}" value="${Math.floor((gameData.grid[selectedStrategyNode].strength - 1) / 2)}" 
                      class="w-full h-2 bg-slate-800 rounded-lg appearance-none cursor-pointer accent-blue-600" />
                    <div class="flex justify-between text-[9px] font-bold text-slate-500 mt-1">
                      <span>1</span>
                      <span id="transfer-amount">${Math.floor((gameData.grid[selectedStrategyNode].strength - 1) / 2)}</span>
                      <span>${gameData.grid[selectedStrategyNode].strength - 1}</span>
                    </div>
                  </div>
                  <div class="text-[9px] font-black text-slate-400 uppercase">
                    Click another<br/>owned node
                  </div>
                </div>
              </div>
            ` : ''}
          </div>
          
          <div class="space-y-4">
            <div class="bg-slate-900 border border-white/10 rounded-3xl p-4 h-[200px] flex flex-col">
              <p class="text-slate-600 font-black mb-2 uppercase text-[9px]">Data Stream</p>
              <div id="strategy-log-container" class="flex-1 overflow-y-auto font-mono text-[9px] space-y-1">
                ${(gameData.logs || []).map(l => `
                  <div class="text-slate-400 opacity-80">
                    <span class="text-blue-500">></span> ${l}
                  </div>
                `).join('')}
              </div>
            </div>
          </div>
          
          <!-- Compact Field Manual -->
          <div class="lg:col-span-4 bg-slate-900/50 border border-white/5 rounded-3xl p-6">
            <div class="flex items-center gap-3 mb-4">
              <div class="bg-blue-600/20 p-2 rounded-xl text-sm">${icons.info}</div>
              <div>
                <h3 class="text-lg font-black uppercase italic text-white tracking-tighter">Field Manual</h3>
                <p class="text-[9px] font-black text-slate-500 uppercase tracking-widest">Tactical Guidelines</p>
              </div>
            </div>
            
            <div class="grid md:grid-cols-3 gap-4">
              <div class="space-y-2">
                <div class="flex items-center gap-2 text-yellow-500 text-sm">
                  ${icons.zap}
                  <h4 class="font-black uppercase italic text-[10px] tracking-widest">Energy Grid</h4>
                </div>
                <p class="text-slate-400 text-[10px] leading-relaxed font-medium">
                  Gain energy each turn based on controlled nodes. More territory = more resources per cycle.
                </p>
              </div>
              
              <div class="space-y-2">
                <div class="flex items-center gap-2 text-blue-500 text-sm">
                  ${icons.sword}
                  <h4 class="font-black uppercase italic text-[10px] tracking-widest">Capture Logic</h4>
                </div>
                <p class="text-slate-400 text-[10px] leading-relaxed font-medium">
                  Select your node, click adjacent to attack. Cost: 2 Energy. Higher strength captures target.
                </p>
              </div>
              
              <div class="space-y-2">
                <div class="flex items-center gap-2 text-emerald-500 text-sm">
                  ${icons.shieldIcon}
                  <h4 class="font-black uppercase italic text-[10px] tracking-widest">Reinforcement</h4>
                </div>
                <p class="text-slate-400 text-[10px] leading-relaxed font-medium">
                  Boost selected node strength. Cost: 1 Energy. Stronger nodes resist attacks.
                </p>
              </div>
            </div>
            
            <div class="mt-4 pt-4 border-t border-white/5 grid grid-cols-2 md:grid-cols-4 gap-3">
              <div class="p-3 bg-black/40 rounded-xl border border-white/5">
                <p class="text-[8px] font-black text-slate-600 uppercase mb-0.5">Victory</p>
                <p class="text-[9px] font-bold text-white">Eliminate all opponents</p>
              </div>
              <div class="p-3 bg-black/40 rounded-xl border border-white/5">
                <p class="text-[8px] font-black text-slate-600 uppercase mb-0.5">Defeat</p>
                <p class="text-[9px] font-bold text-white">Loss of all your nodes</p>
              </div>
              <div class="p-3 bg-black/40 rounded-xl border border-white/5">
                <p class="text-[8px] font-black text-slate-600 uppercase mb-0.5">Players</p>
                <p class="text-[9px] font-bold text-white">${isMulti ? `${gameData.players.length} Active` : 'You vs AI'}</p>
              </div>
              <div class="p-3 bg-black/40 rounded-xl border border-white/5">
                <p class="text-[8px] font-black text-slate-600 uppercase mb-0.5">Energy Cap</p>
                <p class="text-[9px] font-bold text-white">Max 50 energy</p>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function renderPokerGame() {
      const myState = gameData.playerStates?.[currentUser.uid] || { chips: 0, cards: [], contribution: 0, folded: false };
      const opponents = gameData.players.filter(p => p.id !== currentUser.uid);
      const actionStart = gameData.actionStartIndex || 0;
      const currentPlayerIndex = (actionStart + gameData.turnIndex) % gameData.players.length;
      const currentPlayer = gameData.players[currentPlayerIndex];
      const isMyTurn = currentPlayer?.id === currentUser.uid;
      const isResetting = gameData.status === 'resolution' || gameData.status === 'resetting';
      
      console.log('renderPokerGame turn check:', {
        myId: currentUser.uid,
        actionStartIndex: actionStart,
        turnIndex: gameData.turnIndex,
        playerCount: gameData.players.length,
        currentPlayerIndex: currentPlayerIndex,
        currentPlayerId: currentPlayer?.id,
        currentPlayerName: currentPlayer?.name,
        isMyTurn: isMyTurn,
        allPlayers: gameData.players.map((p, i) => ({
          index: i,
          name: p.name,
          id: p.id,
          isMe: p.id === currentUser.uid
        }))
      });
      
      // Evaluate current hand
      const myHand = evaluateHandName(myState.cards || [], gameData.communityCards || []);
      
      return `
        <div class="flex flex-col gap-4 max-w-6xl mx-auto">
          <!-- Turn Indicator -->
          <div class="bg-slate-900 border border-white/10 rounded-2xl p-4 text-center">
            <p class="text-xs font-black uppercase text-slate-500 mb-1">Current Turn</p>
            <p class="text-lg font-black uppercase italic ${isMyTurn ? 'text-blue-400' : 'text-white'}">
              ${isMyTurn ? 'üéØ YOUR TURN' : `‚è≥ ${currentPlayer?.name || 'Waiting...'}`}
            </p>
          </div>
          
          <!-- Poker Table -->
          <div class="relative min-h-[420px] bg-emerald-900/40 rounded-[100px] border-[10px] border-slate-900 flex flex-col items-center justify-center p-8 pt-20 overflow-visible">
            
            <!-- Community Cards & Pot Row -->
            <div class="flex gap-6 relative z-10 items-center">
              <div class="flex gap-3 bg-black/20 p-4 rounded-3xl border border-white/5">
                ${gameData.communityCards.map(c => renderCard(c)).join('')}
                ${Array(Math.max(0, 5 - (gameData.communityCards?.length || 0))).fill(0).map(() => 
                  '<div class="w-14 h-20 border-2 border-dashed border-white/5 rounded-lg bg-black/10"></div>'
                ).join('')}
              </div>
              
              <!-- Pot -->
              <div class="bg-black/90 px-8 py-4 rounded-2xl border border-white/10">
                <p class="text-[9px] font-black text-slate-500 uppercase tracking-widest mb-1 text-center">Pot</p>
                <div class="font-black text-2xl flex items-center gap-2 text-white justify-center">
                  ${icons.coins} $${gameData.pot}
                </div>
              </div>
            </div>
            
            <!-- Opponents - arranged in arc around table -->
            <div class="absolute top-[-50px] w-full max-w-5xl flex ${opponents.length <= 3 ? 'justify-around' : 'justify-between'} px-4 z-20 flex-wrap gap-4">
              ${opponents.map(p => {
                const s = gameData.playerStates[p.id];
                const isTurn = currentPlayer?.id === p.id;
                return `
                  <div class="flex flex-col items-center gap-2 transition-all ${isTurn ? 'scale-110' : 'opacity-85'}">
                    <div class="w-16 h-16 rounded-full border-4 ${isTurn ? 'border-blue-500' : 'border-slate-800'} bg-slate-900 flex items-center justify-center text-2xl relative">
                      ${p.avatar || (p.isAI ? 'ü§ñ' : 'üë§')}
                      ${s?.folded ? '<div class="absolute inset-0 bg-black/85 flex items-center justify-center text-[8px] font-black text-red-500 uppercase">FOLD</div>' : ''}
                    </div>
                    <div class="flex gap-1 h-10">
                      ${s?.cards?.map(c => `
                        <div class="w-7 h-10 bg-white rounded-md flex items-center justify-center border border-slate-300">
                          ${isResetting && !s.folded ? 
                            `<div class="text-[9px] font-black ${['‚ô•','‚ô¶'].includes(c.suit) ? 'text-red-600' : 'text-slate-900'}">${c.rank}${c.suit}</div>` : 
                            '<div class="w-full h-full bg-blue-900 rounded-md"></div>'
                          }
                        </div>
                      `).join('') || ''}
                    </div>
                    <div class="bg-black px-2 py-1 rounded-full text-[9px] font-black border border-white/10">
                      <p class="text-emerald-400 truncate max-w-[80px]">${p.name}</p>
                      <p class="text-white text-center">$${s?.chips || 0}</p>
                      ${s?.contribution > 0 ? `<p class="text-blue-400 text-center text-[8px]">Bet: $${s.contribution}</p>` : ''}
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>

          <!-- Player Controls -->
          <div class="grid md:grid-cols-3 gap-4">
            <div class="md:col-span-2 bg-slate-900 border border-white/10 rounded-3xl p-6 flex items-center gap-8 relative overflow-hidden min-h-[200px]">
              ${isResetting ? `
                <div class="absolute inset-0 bg-black/70 backdrop-blur-xl z-20 flex flex-col items-center justify-center">
                  <div class="animate-spin text-blue-500 mb-3 text-sm">${icons.refresh}</div>
                  <span class="font-black italic text-white text-sm">Resetting Cycle...</span>
                </div>
              ` : ''}
              
              <div class="flex flex-col gap-3">
                <div class="flex gap-2 p-3 bg-black/40 rounded-3xl border border-white/5">
                  ${myState.cards?.map(c => renderCard(c)).join('') || ''}
                </div>
                ${myHand ? `
                  <div class="px-4 py-2 bg-blue-600/20 border border-blue-500/30 rounded-xl text-center">
                    <p class="text-[9px] font-black text-blue-400 uppercase tracking-widest mb-0.5">Your Hand</p>
                    <p class="text-sm font-black text-white uppercase italic">${myHand}</p>
                  </div>
                ` : ''}
              </div>
              
              <div class="flex-1 space-y-4">
                <div class="flex justify-between items-center text-[10px] font-black uppercase">
                  <div class="text-slate-500">In Pot: <span class="text-white">$${myState.contribution}</span></div>
                  <div class="text-emerald-400">Balance: $${myState.chips}</div>
                </div>
                <div class="grid grid-cols-2 gap-2">
                  <button id="fold-btn" ${!isMyTurn || myState.folded || isResetting ? 'disabled' : ''} 
                    class="py-3 bg-white/5 rounded-2xl font-black uppercase text-[10px] text-white disabled:opacity-50">
                    Fold
                  </button>
                  <button id="call-btn" ${!isMyTurn || myState.folded || isResetting ? 'disabled' : ''} 
                    class="py-3 bg-blue-600 rounded-2xl font-black uppercase text-[10px] text-white disabled:opacity-50">
                    ${gameData.currentBet === myState.contribution ? 'Check' : 'Call'}
                  </button>
                  <div class="col-span-2 flex gap-2">
                    <div class="relative flex-1">
                      <div class="absolute left-3 top-1/2 -translate-y-1/2 text-emerald-500 font-black text-xs">$</div>
                      <input type="number" id="bet-input" value="${betAmount}" 
                        class="w-full h-full bg-black/90 border border-white/20 rounded-2xl pl-8 pr-4 py-3 font-bold text-white focus:border-emerald-500 outline-none text-sm" />
                    </div>
                    <button id="raise-btn" ${!isMyTurn || myState.folded || isResetting ? 'disabled' : ''} 
                      class="px-8 py-3 bg-emerald-600 rounded-2xl font-black uppercase text-[10px] text-white disabled:opacity-50">
                      Raise
                    </button>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Action Log -->
            <div class="bg-slate-900 border border-white/10 rounded-3xl p-4 h-[200px] flex flex-col">
              <div id="poker-log-container" class="flex-1 overflow-y-auto font-mono text-[9px] space-y-1">
                ${(gameData.logs || []).map(l => `
                  <div class="p-1.5 rounded bg-white/5 border-l-2 border-slate-700 text-slate-400">${l}</div>
                `).join('')}
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function renderCard({ suit, rank }) {
      return `
        <div class="w-14 h-20 bg-white rounded-lg flex flex-col justify-between p-1.5 border border-slate-200 shadow-xl">
          <div class="font-black text-xs ${['‚ô•','‚ô¶'].includes(suit) ? 'text-red-600' : 'text-slate-900'}">${rank}</div>
          <div class="text-2xl self-center ${['‚ô•','‚ô¶'].includes(suit) ? 'text-red-600' : 'text-slate-900'}">${suit}</div>
          <div class="font-black text-xs rotate-180 ${['‚ô•','‚ô¶'].includes(suit) ? 'text-red-600' : 'text-slate-900'}">${rank}</div>
        </div>
      `;
    }
    
    function renderBullshitGame() {
      const myHand = gameData.hands[currentUser.uid] || [];
      const isMyTurn = gameData.turn === currentUser.uid;
      const currentPlayer = gameData.players.find(p => p.id === gameData.turn);
      const isGameOver = gameData.status === 'ended';
      
      // Count how many of the required rank the player has
      const requiredRank = gameData.currentRank;
      const matchingCards = myHand.filter(c => c.rank === requiredRank);
      
      return `
        <div class="flex flex-col gap-4 max-w-6xl mx-auto pb-4">
          <!-- Turn Indicator -->
          <div class="bg-slate-900 border border-white/10 rounded-2xl p-4 text-center">
            <p class="text-xs font-black uppercase text-slate-500 mb-1">Current Turn</p>
            <p class="text-lg font-black uppercase italic ${isMyTurn ? 'text-yellow-400' : 'text-white'}">
              ${isMyTurn ? 'üéØ YOUR TURN' : `‚è≥ ${currentPlayer?.name || 'Waiting...'}`}
            </p>
            <div class="mt-3 p-3 bg-yellow-600/20 border border-yellow-500/30 rounded-xl">
              <p class="text-sm text-slate-400">Must Play: <span class="text-white font-black text-2xl">${requiredRank}</span></p>
              ${isMyTurn ? `<p class="text-xs text-yellow-400 mt-1">You have ${matchingCards.length} ${requiredRank}${matchingCards.length !== 1 ? 's' : ''}</p>` : ''}
            </div>
          </div>
          
          <!-- Game Area -->
          <div class="grid lg:grid-cols-4 gap-4">
            <!-- Main Play Area -->
            <div class="lg:col-span-3 space-y-4">
              <!-- Pile & Last Claim -->
              <div class="bg-slate-900 border border-white/10 rounded-2xl p-6">
                <div class="grid md:grid-cols-2 gap-6">
                  <div class="text-center">
                    <p class="text-xs font-black uppercase text-slate-500 mb-3">Pile</p>
                    <div class="bg-black/40 rounded-xl p-6 border border-white/5">
                      <div class="text-5xl mb-2">üÉè</div>
                      <p class="text-2xl font-black text-white">${gameData.pile.length}</p>
                      <p class="text-xs text-slate-500 mt-1">cards</p>
                    </div>
                  </div>
                  
                  <div>
                    <p class="text-xs font-black uppercase text-slate-500 mb-3">Last Claim</p>
                    <div class="bg-black/40 rounded-xl p-4 border border-white/5 min-h-[160px] flex flex-col justify-between">
                      ${gameData.lastClaim ? `
                        <div>
                          <p class="text-white font-bold mb-2">${gameData.lastClaim.playerName}</p>
                          <p class="text-slate-400 text-sm mb-1">Claimed: <span class="text-yellow-400 font-black text-lg">${gameData.lastClaim.count} ${gameData.lastClaim.rank}${gameData.lastClaim.count > 1 ? 's' : ''}</span></p>
                          ${gameData.canCallBS ? `
                            <p class="text-red-400 text-xs mt-2 font-black" id="bs-timer-display">‚è±Ô∏è 3s to call BS!</p>
                          ` : ''}
                        </div>
                        ${gameData.canCallBS && !isGameOver ? `
                          <button id="call-bs-btn" class="w-full py-3 bg-red-600 hover:bg-red-500 rounded-xl font-black uppercase text-sm text-white transition-all shadow-lg pulse-bs">
                            üö® Call Bullshit!
                          </button>
                        ` : ''}
                      ` : '<p class="text-slate-500 text-sm">No claims yet</p>'}
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Player's Hand -->
              <div class="bg-slate-900 border border-white/10 rounded-2xl p-6">
                <div class="flex justify-between items-center mb-4">
                  <p class="text-sm font-black uppercase text-slate-400">Your Hand (${myHand.length} cards)</p>
                  ${isMyTurn && !isGameOver ? `
                    <button id="play-selected-btn" disabled class="px-8 py-3 bg-yellow-600 hover:bg-yellow-500 disabled:opacity-50 disabled:cursor-not-allowed rounded-xl font-black uppercase text-sm text-white transition-all">
                      Play <span id="selected-count">0</span> Cards
                    </button>
                  ` : ''}
                </div>
                
                <div class="flex gap-2 flex-wrap justify-center min-h-[120px] bg-black/20 rounded-xl p-4">
                  ${myHand.map((card, index) => `
                    <div class="bullshit-card relative cursor-pointer transition-transform hover:scale-105" data-card-index="${index}" data-rank="${card.rank}" data-suit="${card.suit}">
                      <div class="w-14 h-20 bg-white rounded-lg flex flex-col justify-between p-1.5 border-2 border-slate-200 shadow-xl transition-all">
                        <div class="font-black text-xs ${['‚ô•','‚ô¶'].includes(card.suit) ? 'text-red-600' : 'text-slate-900'}">${card.rank}</div>
                        <div class="text-2xl self-center ${['‚ô•','‚ô¶'].includes(card.suit) ? 'text-red-600' : 'text-slate-900'}">${card.suit}</div>
                        <div class="font-black text-xs rotate-180 ${['‚ô•','‚ô¶'].includes(card.suit) ? 'text-red-600' : 'text-slate-900'}">${card.rank}</div>
                      </div>
                      <div class="selected-indicator hidden absolute -top-2 -right-2 w-6 h-6 bg-yellow-500 rounded-full border-2 border-white flex items-center justify-center text-xs font-black">‚úì</div>
                    </div>
                  `).join('')}
                  ${myHand.length === 0 ? '<p class="text-slate-600 text-center w-full py-8">No cards</p>' : ''}
                </div>
                
                ${isMyTurn && myHand.length > 0 && !isGameOver ? `
                  <div class="mt-4 p-3 bg-blue-600/10 border border-blue-500/20 rounded-xl">
                    <p class="text-xs text-blue-400 text-center">üí° Click cards to select them, then click "Play X Cards" to claim you're playing ${requiredRank}s</p>
                  </div>
                ` : ''}
              </div>
              
              ${isGameOver ? `
                <div class="bg-green-600/20 border border-green-500/50 rounded-2xl p-6 text-center">
                  <p class="text-3xl mb-2">üéâ</p>
                  <p class="text-2xl font-black text-white uppercase">Game Over!</p>
                  <p class="text-green-400 mt-2">${gameData.players.find(p => p.id === gameData.winner)?.name || 'Someone'} wins!</p>
                  <button id="return-menu-btn" class="mt-4 px-8 py-3 bg-blue-600 hover:bg-blue-500 rounded-xl font-black uppercase text-white transition-all">
                    Return to Menu
                  </button>
                </div>
              ` : ''}
            </div>
            
            <!-- Sidebar - Players & Log -->
            <div class="space-y-4">
              <!-- Players -->
              <div class="bg-slate-900 border border-white/10 rounded-2xl p-4">
                <p class="text-xs font-black uppercase text-slate-500 mb-3">Players</p>
                <div class="space-y-2">
                  ${gameData.players.map(p => {
                    const hand = gameData.hands[p.id] || [];
                    const isCurrent = p.id === gameData.turn;
                    return `
                      <div class="p-3 rounded-xl ${isCurrent ? 'bg-yellow-600/20 border border-yellow-500/30' : 'bg-black/20 border border-white/5'}">
                        <div class="flex items-center gap-2">
                          <div class="text-xl">${p.avatar || 'üë§'}</div>
                          <div class="flex-1">
                            <p class="font-bold text-white text-sm ${isCurrent ? 'text-yellow-400' : ''}">${p.name}</p>
                            <p class="text-xs text-slate-400">${hand.length} cards</p>
                          </div>
                        </div>
                      </div>
                    `;
                  }).join('')}
                </div>
              </div>
              
              <!-- Game Log -->
              <div class="bg-slate-900 border border-white/10 rounded-2xl p-4">
                <p class="text-xs font-black uppercase text-slate-500 mb-3">Game Log</p>
                <div class="space-y-1 max-h-60 overflow-y-auto text-xs font-mono">
                  ${(gameData.logs || []).slice(-10).map(log => `
                    <div class="p-2 bg-black/20 rounded border-l-2 border-yellow-500/30 text-slate-400">${log}</div>
                  `).join('')}
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <style>
          @keyframes pulse-bs {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
          }
          .pulse-bs {
            animation: pulse-bs 0.8s infinite;
          }
        </style>
      `;
    }
    
    function renderSpadesGame() {
      const myHand = gameData.hands[currentUser.uid] || [];
      const isMyTurn = gameData.turn === currentUser.uid;
      const currentPlayer = gameData.players.find(p => p.id === gameData.turn);
      const isGameOver = gameData.status === 'ended';
      const isBidding = gameData.phase === 'bidding';
      
      // Determine teams
      const isPlayerTeam1 = gameData.partnerships.team1.includes(currentUser.uid);
      const myTeam = isPlayerTeam1 ? 'team1' : 'team2';
      const opponentTeam = isPlayerTeam1 ? 'team2' : 'team1';
      
      const partnerName = gameData.players.find(p => 
        p.id !== currentUser.uid && gameData.partnerships[myTeam].includes(p.id)
      )?.name || 'Partner';
      
      return `
        <div class="flex flex-col gap-4 max-w-6xl mx-auto pb-4">
          <!-- Header -->
          <div class="bg-slate-900 border border-white/10 rounded-2xl p-4">
            <div class="grid grid-cols-3 gap-4">
              <div class="text-center">
                <p class="text-xs font-black uppercase text-slate-500">Round</p>
                <p class="text-2xl font-black text-white">${gameData.round || 1}</p>
              </div>
              <div class="text-center">
                <p class="text-xs font-black uppercase text-slate-500">${isBidding ? 'Bidding Phase' : 'Trick ' + ((gameData.tricks || 0) + 1)}</p>
                <p class="text-lg font-black uppercase italic ${isMyTurn ? 'text-green-400' : 'text-white'}">
                  ${isMyTurn ? 'üéØ YOUR TURN' : `‚è≥ ${currentPlayer?.name || 'Waiting...'}`}
                </p>
              </div>
              <div class="text-center">
                <p class="text-xs font-black uppercase text-slate-500">Partner</p>
                <p class="text-lg font-black text-white">${partnerName}</p>
              </div>
            </div>
          </div>
          
          <div class="grid lg:grid-cols-4 gap-4">
            <!-- Main Play Area -->
            <div class="lg:col-span-3 space-y-4">
              <!-- Current Trick -->
              ${!isBidding ? `
                <div class="bg-slate-900 border border-white/10 rounded-2xl p-6">
                  <p class="text-xs font-black uppercase text-slate-500 mb-4">Current Trick</p>
                  <div class="grid grid-cols-4 gap-4 min-h-[120px]">
                    ${gameData.players.map(p => {
                      const play = gameData.currentTrick?.find(t => t.playerId === p.id);
                      return `
                        <div class="text-center">
                          <div class="mb-2">
                            <p class="text-xs text-slate-400 font-bold">${p.name}</p>
                            <p class="text-xl">${p.avatar || 'üë§'}</p>
                          </div>
                          ${play ? renderCard(play.card) : '<div class="w-14 h-20 border-2 border-dashed border-white/5 rounded-lg bg-black/10 mx-auto"></div>'}
                        </div>
                      `;
                    }).join('')}
                  </div>
                  ${gameData.leadingSuit ? `<p class="text-xs text-center text-slate-500 mt-3">Leading Suit: ${gameData.leadingSuit}</p>` : ''}
                </div>
              ` : ''}
              
              <!-- Player's Hand / Bidding -->
              <div class="bg-slate-900 border border-white/10 rounded-2xl p-6">
                <div class="flex justify-between items-center mb-4">
                  <p class="text-sm font-black uppercase text-slate-400">
                    ${isBidding ? 'Place Your Bid' : `Your Hand (${myHand.length} cards)`}
                  </p>
                </div>
                
                ${isBidding ? `
                  <div class="space-y-4">
                    <div class="p-4 bg-blue-600/10 border border-blue-500/20 rounded-xl">
                      <p class="text-sm text-blue-400 mb-3">How many tricks can you win?</p>
                      <div class="grid grid-cols-7 gap-2">
                        ${[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13].map(bid => `
                          <button class="spades-bid-btn py-3 bg-white/5 hover:bg-green-600 rounded-xl font-black text-white transition-all" data-bid="${bid}">
                            ${bid}
                          </button>
                        `).join('')}
                      </div>
                    </div>
                    <div class="flex gap-2 flex-wrap justify-center bg-black/20 rounded-xl p-4 min-h-[120px]">
                      ${myHand.map(card => renderCard(card)).join('')}
                    </div>
                  </div>
                ` : `
                  <div class="flex gap-2 flex-wrap justify-center min-h-[120px] bg-black/20 rounded-xl p-4">
                    ${myHand.map((card, index) => {
                      const canPlay = isMyTurn && canPlayCard(card, myHand, gameData.currentTrick || [], gameData.leadingSuit);
                      return `
                        <div class="spades-card relative ${canPlay ? 'cursor-pointer hover:scale-110' : 'opacity-50 cursor-not-allowed'} transition-transform" data-card-index="${index}" data-rank="${card.rank}" data-suit="${card.suit}">
                          ${renderCard(card)}
                        </div>
                      `;
                    }).join('')}
                  </div>
                `}
              </div>
              
              ${isGameOver ? `
                <div class="bg-green-600/20 border border-green-500/50 rounded-2xl p-6 text-center">
                  <p class="text-3xl mb-2">üéâ</p>
                  <p class="text-2xl font-black text-white uppercase">Game Over!</p>
                  <p class="text-green-400 mt-2">Team ${gameData.winner === 'team1' ? '1' : '2'} wins!</p>
                  <button id="return-menu-btn" class="mt-4 px-8 py-3 bg-blue-600 hover:bg-blue-500 rounded-xl font-black uppercase text-white transition-all">
                    Return to Menu
                  </button>
                </div>
              ` : ''}
            </div>
            
            <!-- Sidebar -->
            <div class="space-y-4">
              <!-- Scores -->
              <div class="bg-slate-900 border border-white/10 rounded-2xl p-4">
                <p class="text-xs font-black uppercase text-slate-500 mb-3">Scores</p>
                <div class="space-y-3">
                  <div class="p-3 rounded-xl ${myTeam === 'team1' ? 'bg-green-600/20 border border-green-500/30' : 'bg-black/20 border border-white/5'}">
                    <p class="text-xs text-slate-400">Team 1 (You & Partner)</p>
                    <p class="text-2xl font-black text-white">${gameData.scores?.team1 || 0}</p>
                    <p class="text-xs text-slate-500">Bags: ${gameData.bags?.team1 || 0}</p>
                  </div>
                  <div class="p-3 rounded-xl ${myTeam === 'team2' ? 'bg-green-600/20 border border-green-500/30' : 'bg-black/20 border border-white/5'}">
                    <p class="text-xs text-slate-400">Team 2 (Opponents)</p>
                    <p class="text-2xl font-black text-white">${gameData.scores?.team2 || 0}</p>
                    <p class="text-xs text-slate-500">Bags: ${gameData.bags?.team2 || 0}</p>
                  </div>
                </div>
              </div>
              
              <!-- Bids & Tricks -->
              <div class="bg-slate-900 border border-white/10 rounded-2xl p-4">
                <p class="text-xs font-black uppercase text-slate-500 mb-3">Bids & Tricks</p>
                <div class="space-y-2">
                  ${gameData.players.map(p => {
                    const bid = gameData.bids?.[p.id];
                    const tricks = gameData.tricksWon?.[p.id] || 0;
                    return `
                      <div class="p-2 rounded-xl bg-black/20 border border-white/5">
                        <div class="flex items-center gap-2">
                          <span class="text-lg">${p.avatar || 'üë§'}</span>
                          <div class="flex-1">
                            <p class="text-xs font-bold text-white">${p.name}</p>
                            <p class="text-xs text-slate-400">
                              ${bid !== undefined ? `Bid: ${bid}` : 'Bidding...'}
                              ${!isBidding ? ` | Won: ${tricks}` : ''}
                            </p>
                          </div>
                        </div>
                      </div>
                    `;
                  }).join('')}
                </div>
              </div>
              
              <!-- Game Log -->
              <div class="bg-slate-900 border border-white/10 rounded-2xl p-4">
                <p class="text-xs font-black uppercase text-slate-500 mb-3">Game Log</p>
                <div class="space-y-1 max-h-60 overflow-y-auto text-xs font-mono">
                  ${(gameData.logs || []).slice(-10).map(log => `
                    <div class="p-2 bg-black/20 rounded border-l-2 border-green-500/30 text-slate-400">${log}</div>
                  `).join('')}
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    // Event Listeners
    function attachAuthListeners() {
      const form = document.getElementById('auth-form');
      const toggleBtn = document.getElementById('toggle-mode');
      const displayNameField = document.getElementById('displayname-field');
      const submitBtn = document.getElementById('auth-submit');
      let isLogin = true;

      toggleBtn.addEventListener('click', () => {
        isLogin = !isLogin;
        if (isLogin) {
          displayNameField.classList.add('hidden');
          submitBtn.textContent = 'Infiltrate';
          toggleBtn.textContent = 'NEW RECRUIT? REGISTER HERE';
        } else {
          displayNameField.classList.remove('hidden');
          submitBtn.textContent = 'Establish Link';
          toggleBtn.textContent = 'ALREADY ENLISTED? LOGIN';
        }
      });

      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const email = document.getElementById('email').value;
        const password = document.getElementById('password').value;
        const displayName = document.getElementById('displayName').value;
        const errorDiv = document.getElementById('auth-error');
        
        submitBtn.disabled = true;
        submitBtn.innerHTML = `<span class="animate-spin inline-block">${icons.refresh}</span>`;
        errorDiv.classList.add('hidden');

        try {
          if (isLogin) {
            await signInWithEmailAndPassword(auth, email, password);
          } else {
            const userCredential = await createUserWithEmailAndPassword(auth, email, password);
            await updateProfile(userCredential.user, { 
              displayName: displayName || email.split('@')[0] 
            });
          }
        } catch (err) {
          errorDiv.textContent = err.message.replace('Firebase:', '');
          errorDiv.classList.remove('hidden');
        } finally {
          submitBtn.disabled = false;
          submitBtn.textContent = isLogin ? 'Infiltrate' : 'Establish Link';
        }
      });
      
      // Google Sign-In
      const googleSignInBtn = document.getElementById('google-signin-btn');
      if (googleSignInBtn) {
        googleSignInBtn.addEventListener('click', async () => {
          const errorDiv = document.getElementById('auth-error');
          errorDiv.classList.add('hidden');
          
          try {
            const provider = new GoogleAuthProvider();
            // Explicitly set the client ID
            provider.setCustomParameters({
              prompt: 'select_account',
              client_id: '441287288010-q519vqjkql0fkviodtvlmcf1g4sh8499.apps.googleusercontent.com'
            });
            await signInWithPopup(auth, provider);
          } catch (err) {
            console.error('Google Sign-In Error:', err);
            console.error('Error code:', err.code);
            console.error('Error message:', err.message);
            
            // Provide helpful error messages
            let errorMessage = err.message.replace('Firebase:', '').trim();
            
            if (err.code === 'auth/operation-not-allowed') {
              errorMessage = 'Google Sign-In configuration issue. Please ensure:\n1. Google provider is enabled in Firebase Console\n2. Project support email is set\n3. This domain is authorized';
            } else if (err.code === 'auth/popup-closed-by-user') {
              errorMessage = 'Sign-in cancelled. Please try again.';
            } else if (err.code === 'auth/popup-blocked') {
              errorMessage = 'Popup blocked by browser. Please allow popups and try again.';
            } else if (err.code === 'auth/unauthorized-domain') {
              errorMessage = 'This domain is not authorized. Add it in Firebase Console ‚Üí Authentication ‚Üí Settings ‚Üí Authorized domains';
            }
            
            errorDiv.innerHTML = errorMessage.replace(/\n/g, '<br>');
            errorDiv.classList.remove('hidden');
          }
        });
      }
      
      // Forgot Password Modal
      const forgotPasswordBtn = document.getElementById('forgot-password-btn');
      const forgotPasswordModal = document.getElementById('forgot-password-modal');
      const cancelResetBtn = document.getElementById('cancel-reset-btn');
      const sendResetBtn = document.getElementById('send-reset-btn');
      
      if (forgotPasswordBtn) {
        forgotPasswordBtn.addEventListener('click', () => {
          forgotPasswordModal.classList.remove('hidden');
          document.getElementById('reset-error').classList.add('hidden');
          document.getElementById('reset-success').classList.add('hidden');
          document.getElementById('reset-email').value = '';
        });
      }
      
      if (cancelResetBtn) {
        cancelResetBtn.addEventListener('click', () => {
          forgotPasswordModal.classList.add('hidden');
        });
      }
      
      // Click outside modal to close
      if (forgotPasswordModal) {
        forgotPasswordModal.addEventListener('click', (e) => {
          if (e.target === forgotPasswordModal) {
            forgotPasswordModal.classList.add('hidden');
          }
        });
      }
      
      if (sendResetBtn) {
        sendResetBtn.addEventListener('click', async () => {
          const email = document.getElementById('reset-email').value;
          const resetError = document.getElementById('reset-error');
          const resetSuccess = document.getElementById('reset-success');
          
          resetError.classList.add('hidden');
          resetSuccess.classList.add('hidden');
          
          if (!email) {
            resetError.textContent = 'Please enter your email address';
            resetError.classList.remove('hidden');
            return;
          }
          
          try {
            sendResetBtn.disabled = true;
            sendResetBtn.textContent = 'Sending...';
            
            console.log('Attempting to send password reset email to:', email);
            
            await sendPasswordResetEmail(auth, email, {
              url: window.location.origin,
              handleCodeInApp: false
            });
            
            console.log('Password reset email sent successfully');
            
            resetSuccess.innerHTML = `
              <div class="flex justify-between items-start gap-3">
                <div class="flex-1">
                  ‚úÖ Password reset email sent!<br>
                  <br>
                  <strong>üìß Check your inbox</strong><br>
                  <span class="text-xs">The email should arrive in 1-2 minutes.</span><br>
                  <br>
                  <strong>üì´ Not there?</strong><br>
                  <span class="text-xs">‚Ä¢ Check your <strong>spam/junk folder</strong><br>
                  ‚Ä¢ Look for email from Firebase Authentication<br>
                  ‚Ä¢ Add noreply@retro-royal-casino.firebaseapp.com to contacts</span>
                </div>
                <button onclick="document.getElementById('forgot-password-modal').classList.add('hidden')" class="text-2xl text-green-400 hover:text-white transition-colors leading-none">&times;</button>
              </div>
            `;
            resetSuccess.classList.remove('hidden');
          } catch (err) {
            console.error('Password reset error:', err);
            console.error('Error code:', err.code);
            
            let errorMessage = err.message.replace('Firebase:', '').trim();
            
            if (err.code === 'auth/user-not-found') {
              errorMessage = 'No account found with this email address.';
            } else if (err.code === 'auth/invalid-email') {
              errorMessage = 'Please enter a valid email address.';
            } else if (err.code === 'auth/missing-continue-uri') {
              errorMessage = 'Configuration error. Please contact support.';
            } else if (err.code === 'auth/too-many-requests') {
              errorMessage = 'Too many attempts. Please try again later.';
            }
            
            resetError.textContent = errorMessage;
            resetError.classList.remove('hidden');
          } finally {
            sendResetBtn.disabled = false;
            sendResetBtn.textContent = 'Send Reset Link';
          }
        });
      }
    }

    function attachProfileListeners() {
      document.getElementById('back-btn').addEventListener('click', () => {
        currentPage = 'menu';
        render();
      });

      document.getElementById('home-btn').addEventListener('click', () => {
        currentPage = 'menu';
        render();
      });

      document.getElementById('profile-btn').addEventListener('click', () => {
        currentPage = 'profile';
        render();
      });

      document.getElementById('signout-btn').addEventListener('click', async () => {
        await signOut(auth);
      });

      document.getElementById('profile-signout-btn').addEventListener('click', async () => {
        await signOut(auth);
      });

      document.getElementById('update-profile-btn').addEventListener('click', async () => {
        try {
          const newName = document.getElementById('profile-name').value;
          await updateProfile(auth.currentUser, { displayName: newName });
          currentUser = auth.currentUser;
          const statusDiv = document.getElementById('profile-status');
          statusDiv.textContent = 'Profile updated!';
          statusDiv.classList.remove('hidden');
          setTimeout(() => statusDiv.classList.add('hidden'), 2000);
        } catch (e) {
          console.error('Error updating profile:', e);
        }
      });

      document.getElementById('topup-btn').addEventListener('click', () => {
        if (!gameData || !gameData.playerStates) return;
        const states = { ...gameData.playerStates };
        if (states[currentUser.uid]) {
          states[currentUser.uid].chips = 2000;
          states[currentUser.uid].folded = false;
          states[currentUser.uid].isAllIn = false;
          updateGameState({ 
            playerStates: states, 
            logs: [...(gameData.logs || []), "üí∞ Credits restored to $2000"] 
          });
          updateStats({ totalChips: 2000 });
          const statusDiv = document.getElementById('profile-status');
          statusDiv.textContent = 'Credits Repaired!';
          statusDiv.classList.remove('hidden');
          setTimeout(() => statusDiv.classList.add('hidden'), 2000);
        }
      });

      document.getElementById('delete-account-btn').addEventListener('click', () => {
        document.getElementById('delete-confirm').classList.remove('hidden');
      });

      document.getElementById('cancel-delete-btn').addEventListener('click', () => {
        document.getElementById('delete-confirm').classList.add('hidden');
      });

      document.getElementById('confirm-delete-btn').addEventListener('click', async () => {
        try {
          await deleteUser(auth.currentUser);
        } catch (e) {
          console.error('Error deleting user:', e);
        }
      });

      // Rank info modal
      const rankInfoBtn = document.getElementById('rank-info-btn');
      const rankModal = document.getElementById('rank-modal');
      
      // Avatar modal
      let selectedAvatar = userStats.avatar || 'üë§';
      
      const changeAvatarBtn = document.getElementById('change-avatar-btn');
      if (changeAvatarBtn) {
        changeAvatarBtn.addEventListener('click', () => {
          document.getElementById('avatar-modal').classList.remove('hidden');
        });
      }
      
      const closeAvatarModal = document.getElementById('close-avatar-modal');
      if (closeAvatarModal) {
        closeAvatarModal.addEventListener('click', () => {
          document.getElementById('avatar-modal').classList.add('hidden');
        });
      }
      
      // Click outside modal to close
      const avatarModal = document.getElementById('avatar-modal');
      if (avatarModal) {
        avatarModal.addEventListener('click', (e) => {
          if (e.target === avatarModal) {
            avatarModal.classList.add('hidden');
          }
        });
      }
      
      // Avatar selection
      document.querySelectorAll('.avatar-option').forEach(btn => {
        btn.addEventListener('click', (e) => {
          selectedAvatar = e.currentTarget.getAttribute('data-avatar');
          // Update visual selection
          document.querySelectorAll('.avatar-option').forEach(b => {
            b.classList.remove('border-blue-500');
            b.classList.add('border-white/10');
          });
          e.currentTarget.classList.remove('border-white/10');
          e.currentTarget.classList.add('border-blue-500');
        });
      });
      
      const saveAvatarBtn = document.getElementById('save-avatar-btn');
      if (saveAvatarBtn) {
        saveAvatarBtn.addEventListener('click', async () => {
          await updateStats({ avatar: selectedAvatar });
          document.getElementById('avatar-modal').classList.add('hidden');
          render();
        });
      }
      const closeRankModal = document.getElementById('close-rank-modal');
      
      if (rankInfoBtn) {
        rankInfoBtn.addEventListener('click', () => {
          rankModal.classList.remove('hidden');
        });
      }
      
      if (closeRankModal) {
        closeRankModal.addEventListener('click', () => {
          rankModal.classList.add('hidden');
        });
      }
      
      // Close modal on background click
      rankModal?.addEventListener('click', (e) => {
        if (e.target === rankModal) {
          rankModal.classList.add('hidden');
        }
      });
    }

    function attachHomeListeners() {
      document.getElementById('home-btn').addEventListener('click', () => {
        currentPage = 'menu';
        render();
      });

      document.getElementById('profile-btn').addEventListener('click', () => {
        currentPage = 'profile';
        render();
      });

      document.getElementById('signout-btn').addEventListener('click', async () => {
        await signOut(auth);
      });

      document.getElementById('poker-solo-btn').addEventListener('click', () => {
        currentPage = 'poker-setup';
        render();
      });

      document.getElementById('poker-multi-btn').addEventListener('click', async () => {
        currentPage = 'poker-lobby';
        await loadLobbies(GAME_TYPES.POKER);
        render();
      });

      document.getElementById('strategy-solo-btn').addEventListener('click', () => {
        isMultiplayer = false;
        startStrategyGame();
      });

      document.getElementById('strategy-multi-btn').addEventListener('click', async () => {
        currentPage = 'strategy-lobby';
        await loadLobbies(GAME_TYPES.STRATEGY);
        render();
      });
      
      document.getElementById('bullshit-solo-btn').addEventListener('click', () => {
        isMultiplayer = false;
        startBullshitGame();
      });
      
      document.getElementById('bullshit-multi-btn').addEventListener('click', async () => {
        currentPage = 'bullshit-lobby';
        await loadLobbies(GAME_TYPES.BULLSHIT);
        render();
      });
      
      document.getElementById('spades-solo-btn')?.addEventListener('click', () => {
        isMultiplayer = false;
        startSpadesGame();
      });
      
      document.getElementById('spades-multi-btn')?.addEventListener('click', async () => {
        currentPage = 'spades-lobby';
        await loadLobbies(GAME_TYPES.SPADES);
        render();
      });
    }
    
    function attachPokerSetupListeners() {
      document.querySelectorAll('.ai-count-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          aiPlayerCount = parseInt(e.target.dataset.count);
          render();
        });
      });
    
      document.getElementById('start-poker-btn')?.addEventListener('click', () => {
        isMultiplayer = false;
        startPokerGame();
      });
    
      document.getElementById('back-to-menu-btn')?.addEventListener('click', () => {
        currentPage = 'menu';
        render();
      });
    }

    function attachLobbyListeners() {
      document.getElementById('home-btn')?.addEventListener('click', () => {
        if (lobbyUnsubscribe) lobbyUnsubscribe();
        if (window.lobbyListUnsubscribe) window.lobbyListUnsubscribe();
        currentPage = 'menu';
        render();
      });

      document.getElementById('profile-btn')?.addEventListener('click', () => {
        currentPage = 'profile';
        render();
      });

      document.getElementById('signout-btn')?.addEventListener('click', async () => {
        await signOut(auth);
      });

      document.getElementById('lobby-back-btn')?.addEventListener('click', () => {
        if (lobbyUnsubscribe) lobbyUnsubscribe();
        if (window.lobbyListUnsubscribe) window.lobbyListUnsubscribe();
        currentPage = 'menu';
        render();
      });

      document.getElementById('create-lobby-btn')?.addEventListener('click', async () => {
        let gameType = GAME_TYPES.STRATEGY;
        
        if (currentPage === 'poker-lobby') {
          gameType = GAME_TYPES.POKER;
        } else if (currentPage === 'strategy-lobby') {
          gameType = GAME_TYPES.STRATEGY;
        } else if (currentPage === 'bullshit-lobby') {
          gameType = GAME_TYPES.BULLSHIT;
        } else if (currentPage === 'spades-lobby') {
          gameType = GAME_TYPES.SPADES;
        }
        
        await createLobby(gameType);
      });

      // Search functionality
      const searchInput = document.getElementById('lobby-search');
      if (searchInput) {
        searchInput.addEventListener('input', (e) => {
          const searchTerm = e.target.value.toLowerCase().trim();
          const lobbyItems = document.querySelectorAll('.lobby-item');
          
          lobbyItems.forEach(item => {
            const lobbyId = item.getAttribute('data-lobby-id').toLowerCase();
            const hostName = item.getAttribute('data-host-name');
            const lobbyIdText = item.querySelector('.lobby-id')?.textContent.toLowerCase() || '';
            
            if (lobbyId.includes(searchTerm) || hostName.includes(searchTerm) || lobbyIdText.includes(searchTerm)) {
              item.style.display = '';
            } else {
              item.style.display = 'none';
            }
          });
          
          // Show "no results" message if all hidden
          const visibleLobbies = Array.from(lobbyItems).filter(item => item.style.display !== 'none');
          const container = document.getElementById('lobbies-container');
          const existingNoResults = container.querySelector('.no-results-message');
          
          if (visibleLobbies.length === 0 && searchTerm !== '' && !existingNoResults) {
            const noResultsDiv = document.createElement('div');
            noResultsDiv.className = 'no-results-message text-center py-8';
            noResultsDiv.innerHTML = `
              <p class="text-slate-500 font-bold text-sm">No lobbies found</p>
              <p class="text-slate-600 text-xs mt-1">Try a different search term</p>
            `;
            container.appendChild(noResultsDiv);
          } else if (visibleLobbies.length > 0 && existingNoResults) {
            existingNoResults.remove();
          } else if (searchTerm === '' && existingNoResults) {
            existingNoResults.remove();
          }
        });
      }

      // Refresh button
      document.getElementById('refresh-lobbies-btn')?.addEventListener('click', async () => {
        const gameType = currentPage === 'poker-lobby' ? GAME_TYPES.POKER : GAME_TYPES.STRATEGY;
        const btn = document.getElementById('refresh-lobbies-btn');
        btn.style.animation = 'spin 0.5s linear';
        await loadLobbies(gameType);
        render();
        setTimeout(() => {
          if (btn) btn.style.animation = '';
        }, 500);
      });

      document.querySelectorAll('.join-lobby-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const lobbyId = e.target.getAttribute('data-lobby-id');
          await joinLobby(lobbyId);
        });
      });
    }

    function attachWaitingRoomListeners() {
      document.getElementById('home-btn')?.addEventListener('click', () => {
        currentPage = 'menu';
        render();
      });

      document.getElementById('profile-btn')?.addEventListener('click', () => {
        currentPage = 'profile';
        render();
      });

      document.getElementById('signout-btn')?.addEventListener('click', async () => {
        await signOut(auth);
      });

      document.getElementById('leave-lobby-btn')?.addEventListener('click', async () => {
        await leaveLobby();
      });

      document.getElementById('start-game-btn')?.addEventListener('click', async () => {
        await startMultiplayerGame();
      });
    }

    function attachStrategyListeners() {
      document.getElementById('home-btn').addEventListener('click', () => {
        if (unsubscribe) unsubscribe();
        currentPage = 'menu';
        gameData = null;
        selectedStrategyNode = null;
        render();
      });

      document.getElementById('profile-btn').addEventListener('click', () => {
        currentPage = 'profile';
        render();
      });

      document.getElementById('signout-btn').addEventListener('click', async () => {
        await signOut(auth);
      });

      // Node click handlers
      document.querySelectorAll('.strategy-node').forEach(node => {
        node.addEventListener('click', (e) => {
          const index = parseInt(e.currentTarget.getAttribute('data-node-index'));
          handleStrategyNodeClick(index);
        });
      });

      const reinforceBtn = document.getElementById('reinforce-btn');
      if (reinforceBtn) {
        reinforceBtn.addEventListener('click', () => {
          if (selectedStrategyNode !== null && gameData.energy >= 1 && gameData.turn === 'player') {
            const newGrid = [...gameData.grid];
            newGrid[selectedStrategyNode].strength += 1;
            updateGameState({ 
              grid: newGrid, 
              energy: gameData.energy - 1,
              logs: [...gameData.logs, `üõ°Ô∏è Reinforced node [${newGrid[selectedStrategyNode].x}, ${newGrid[selectedStrategyNode].y}]`]
            });
          }
        });
      }

      const endTurnBtn = document.getElementById('end-turn-btn');
      if (endTurnBtn) {
        endTurnBtn.addEventListener('click', () => {
          if (gameData.turn === 'player') {
            updateGameState({ 
              turn: 'ai', 
              logs: [...gameData.logs, "‚åõ Player turn complete"] 
            });
          }
        });
      }

      const restartBtn = document.getElementById('strategy-restart-btn');
      if (restartBtn) {
        restartBtn.addEventListener('click', () => {
          startStrategyGame();
        });
      }
      
      // Transfer slider listener
      const transferSlider = document.getElementById('transfer-slider');
      if (transferSlider) {
        transferSlider.addEventListener('input', (e) => {
          const amountDisplay = document.getElementById('transfer-amount');
          if (amountDisplay) {
            amountDisplay.textContent = e.target.value;
          }
        });
      }

      // Auto-scroll logs
      const logContainer = document.getElementById('strategy-log-container');
      if (logContainer) {
        logContainer.scrollTop = logContainer.scrollHeight;
      }
    }

    function attachPokerListeners() {
      document.getElementById('home-btn').addEventListener('click', () => {
        if (unsubscribe) unsubscribe();
        currentPage = 'menu';
        gameData = null;
        ffActive = false;
        resolutionStarted = false;
        render();
      });

      document.getElementById('profile-btn').addEventListener('click', () => {
        currentPage = 'profile';
        render();
      });

      document.getElementById('signout-btn').addEventListener('click', async () => {
        await signOut(auth);
      });

      const betInput = document.getElementById('bet-input');
      if (betInput) {
        betInput.addEventListener('change', (e) => {
          betAmount = parseInt(e.target.value) || 0;
        });
      }

      document.getElementById('fold-btn')?.addEventListener('click', () => {
        handlePokerAction('FOLD');
      });

      document.getElementById('call-btn')?.addEventListener('click', () => {
        handlePokerAction('CALL');
      });

      document.getElementById('raise-btn')?.addEventListener('click', () => {
        handlePokerAction('RAISE', betAmount);
      });

      // Auto-scroll logs
      const logContainer = document.getElementById('poker-log-container');
      if (logContainer) {
        logContainer.scrollTop = logContainer.scrollHeight;
      }
    }
    
    function attachBullshitListeners() {
      document.getElementById('home-btn').addEventListener('click', () => {
        currentPage = 'menu';
        gameData = null;
        render();
      });

      document.getElementById('profile-btn').addEventListener('click', () => {
        currentPage = 'profile';
        render();
      });

      document.getElementById('signout-btn').addEventListener('click', async () => {
        await signOut(auth);
      });
      
      // BS Timer countdown
      if (gameData.canCallBS && gameData.bsTimer) {
        const updateTimer = () => {
          if (!gameData.canCallBS) return; // Stop if BS window closed
          
          const elapsed = Date.now() - gameData.bsTimer;
          const remaining = Math.max(0, 3 - Math.floor(elapsed / 1000));
          const display = document.getElementById('bs-timer-display');
          
          if (display) {
            display.textContent = `‚è±Ô∏è ${remaining}s to call BS!`;
            if (remaining > 0 && gameData.canCallBS) {
              setTimeout(() => updateTimer(), 100);
            }
          }
        };
        updateTimer();
      }
      
      // Card selection
      let selectedCardIndices = [];
      
      document.querySelectorAll('.bullshit-card').forEach(cardEl => {
        cardEl.addEventListener('click', () => {
          // Only allow card selection on your turn when BS window is closed
          if (gameData.turn !== currentUser.uid || gameData.canCallBS) return;
          
          const index = parseInt(cardEl.dataset.cardIndex);
          const cardDiv = cardEl.querySelector('div');
          const indicator = cardEl.querySelector('.selected-indicator');
          
          if (selectedCardIndices.includes(index)) {
            // Deselect
            selectedCardIndices = selectedCardIndices.filter(i => i !== index);
            cardDiv.classList.remove('border-yellow-500', 'shadow-lg', 'shadow-yellow-500/50');
            cardDiv.classList.add('border-slate-200');
            indicator.classList.add('hidden');
          } else {
            // Select - but limit to 4 cards max
            if (selectedCardIndices.length >= 4) {
              // Flash indicator that max is reached
              const playBtn = document.getElementById('play-selected-btn');
              if (playBtn) {
                playBtn.classList.add('animate-pulse');
                setTimeout(() => playBtn.classList.remove('animate-pulse'), 500);
              }
              return;
            }
            selectedCardIndices.push(index);
            cardDiv.classList.remove('border-slate-200');
            cardDiv.classList.add('border-yellow-500', 'shadow-lg', 'shadow-yellow-500/50');
            indicator.classList.remove('hidden');
          }
          
          // Update button
          const playBtn = document.getElementById('play-selected-btn');
          const countSpan = document.getElementById('selected-count');
          if (playBtn && countSpan) {
            countSpan.textContent = selectedCardIndices.length;
            playBtn.disabled = selectedCardIndices.length === 0;
          }
        });
      });
      
      // Play selected cards button
      const playSelectedBtn = document.getElementById('play-selected-btn');
      if (playSelectedBtn) {
        playSelectedBtn.addEventListener('click', () => {
          if (selectedCardIndices.length === 0) return;
          
          const myHand = gameData.hands[currentUser.uid] || [];
          const cardsToPlay = selectedCardIndices.map(i => myHand[i]);
          const claimedRank = gameData.currentRank;
          
          handleBullshitPlay(cardsToPlay, claimedRank);
          selectedCardIndices = [];
        });
      }
      
      // Call BS button
      const callBSBtn = document.getElementById('call-bs-btn');
      if (callBSBtn) {
        callBSBtn.addEventListener('click', () => {
          handleBullshitCall();
        });
      }
      
      // Return to menu button
      const returnMenuBtn = document.getElementById('return-menu-btn');
      if (returnMenuBtn) {
        returnMenuBtn.addEventListener('click', () => {
          currentPage = 'menu';
          gameData = null;
          render();
        });
      }
    }
    
    function attachSpadesListeners() {
      document.getElementById('home-btn').addEventListener('click', () => {
        currentPage = 'menu';
        gameData = null;
        render();
      });

      document.getElementById('profile-btn').addEventListener('click', () => {
        currentPage = 'profile';
        render();
      });

      document.getElementById('signout-btn').addEventListener('click', async () => {
        await signOut(auth);
      });
      
      // Bid buttons
      document.querySelectorAll('.spades-bid-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const bid = parseInt(btn.dataset.bid);
          handleSpadesBid(bid);
        });
      });
      
      // Card playing
      document.querySelectorAll('.spades-card').forEach(cardEl => {
        cardEl.addEventListener('click', () => {
          const index = parseInt(cardEl.dataset.cardIndex);
          const rank = cardEl.dataset.rank;
          const suit = cardEl.dataset.suit;
          
          const card = { rank, suit };
          handleSpadesPlay(card);
        });
      });
      
      // Return to menu button
      const returnMenuBtn = document.getElementById('return-menu-btn');
      if (returnMenuBtn) {
        returnMenuBtn.addEventListener('click', () => {
          currentPage = 'menu';
          gameData = null;
          render();
        });
      }
    }

    // Multiplayer Lobby Functions
    async function loadLobbies(gameType) {
      try {
        // Unsubscribe from previous lobby list listener if exists
        if (window.lobbyListUnsubscribe) {
          window.lobbyListUnsubscribe();
        }
        
        const lobbiesRef = collection(db, 'lobbies');
        const q = query(
          lobbiesRef,
          where('gameType', '==', gameType),
          where('status', '==', 'waiting'),
          orderBy('createdAt', 'desc')
        );
        
        // Set up real-time listener for lobby list
        window.lobbyListUnsubscribe = onSnapshot(q, (snapshot) => {
          availableLobbies = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
          }));
          
          // Only re-render if we're still on the lobby page
          if (currentPage === 'poker-lobby' || currentPage === 'strategy-lobby') {
            render();
          }
        });
      } catch (error) {
        console.error('Error loading lobbies:', error);
        availableLobbies = [];
      }
    }

    async function createLobby(gameType) {
      try {
        const lobbyId = Math.random().toString(36).substring(2, 9).toUpperCase();
        
        // Set max players based on game type
        let maxPlayers = 8; // Default for Poker and Strategy
        if (gameType === GAME_TYPES.BULLSHIT || gameType === GAME_TYPES.SPADES) {
          maxPlayers = 4; // Bullshit and Spades both need exactly 4 players
        }
        
        const lobbyData = {
          id: lobbyId,
          gameType,
          hostId: currentUser.uid,
          hostName: currentUser.displayName || 'Player',
          players: [{
            id: currentUser.uid,
            name: currentUser.displayName || 'Player',
            avatar: userStats.avatar || 'üë§'
          }],
          maxPlayers,
          status: 'waiting',
          createdAt: Date.now()
        };
        
        console.log('Creating lobby:', lobbyData);
        await setDoc(doc(db, 'lobbies', lobbyId), lobbyData);
        console.log('Lobby created successfully');
        currentLobbyId = lobbyId;
        
        // Listen to lobby changes
        lobbyUnsubscribe = onSnapshot(doc(db, 'lobbies', lobbyId), (snapshot) => {
          if (snapshot.exists()) {
            const lobby = snapshot.data();
            console.log('Lobby update:', lobby);
            if (lobby.status === 'starting') {
              // Game is starting, load game data
              gameData = lobby.gameData;
              gameId = lobbyId;
              isMultiplayer = true;
              currentPage = 'game';
              
              // Stop listening to lobby, start listening to game
              if (lobbyUnsubscribe) lobbyUnsubscribe();
              subscribeToGame(lobbyId);
              render();
            } else {
              // Update waiting room
              gameData = lobby;
              render();
            }
          }
        });
        
        gameData = lobbyData;
        currentPage = 'waiting-room';
        render();
      } catch (error) {
        console.error('Error creating lobby:', error);
        alert('Failed to create lobby: ' + error.message);
      }
    }

    async function joinLobby(lobbyId) {
      try {
        console.log('Attempting to join lobby:', lobbyId);
        const lobbyRef = doc(db, 'lobbies', lobbyId);
        const lobbySnap = await getDoc(lobbyRef);
        
        if (!lobbySnap.exists()) {
          alert('Lobby not found!');
          return;
        }
        
        const lobby = lobbySnap.data();
        console.log('Found lobby:', lobby);
        
        if (lobby.players.length >= lobby.maxPlayers) {
          alert('Lobby is full!');
          return;
        }
        
        // Check if player already in lobby
        if (lobby.players.some(p => p.id === currentUser.uid)) {
          console.log('Player already in lobby, entering waiting room');
          currentLobbyId = lobbyId;
          gameData = lobby;
          currentPage = 'waiting-room';
          
          // Listen to lobby changes
          lobbyUnsubscribe = onSnapshot(lobbyRef, (snapshot) => {
            if (snapshot.exists()) {
              const updatedLobby = snapshot.data();
              if (updatedLobby.status === 'starting') {
                gameData = updatedLobby.gameData;
                gameId = lobbyId;
                isMultiplayer = true;
                currentPage = 'game';
                
                if (lobbyUnsubscribe) lobbyUnsubscribe();
                subscribeToGame(lobbyId);
                render();
              } else {
                gameData = updatedLobby;
                render();
              }
            }
          });
          
          render();
          return;
        }
        
        // Add player to lobby
        const updatedPlayers = [...lobby.players, {
          id: currentUser.uid,
          name: currentUser.displayName || 'Player',
          avatar: userStats.avatar || 'üë§'
        }];
        
        console.log('Adding player to lobby, new players:', updatedPlayers);
        await updateDoc(lobbyRef, {
          players: updatedPlayers
        });
        
        currentLobbyId = lobbyId;
        
        // Listen to lobby changes
        lobbyUnsubscribe = onSnapshot(lobbyRef, (snapshot) => {
          if (snapshot.exists()) {
            const updatedLobby = snapshot.data();
            console.log('Lobby update after join:', updatedLobby);
            if (updatedLobby.status === 'starting') {
              // Game is starting
              gameData = updatedLobby.gameData;
              gameId = lobbyId;
              isMultiplayer = true;
              currentPage = 'game';
              
              if (lobbyUnsubscribe) lobbyUnsubscribe();
              subscribeToGame(lobbyId);
              render();
            } else {
              gameData = updatedLobby;
              render();
            }
          }
        });
        
        gameData = { ...lobby, players: updatedPlayers };
        currentPage = 'waiting-room';
        render();
      } catch (error) {
        console.error('Error joining lobby:', error);
        alert('Failed to join lobby: ' + error.message);
      }
    }

    async function leaveLobby() {
      try {
        if (!currentLobbyId) return;
        
        const lobbyRef = doc(db, 'lobbies', currentLobbyId);
        const lobbySnap = await getDoc(lobbyRef);
        
        if (!lobbySnap.exists()) {
          currentPage = 'menu';
          render();
          return;
        }
        
        const lobby = lobbySnap.data();
        
        if (lobby.hostId === currentUser.uid) {
          // Host is leaving, delete lobby
          await deleteDoc(lobbyRef);
        } else {
          // Remove player from lobby
          const updatedPlayers = lobby.players.filter(p => p.id !== currentUser.uid);
          await updateDoc(lobbyRef, {
            players: updatedPlayers
          });
        }
        
        if (lobbyUnsubscribe) lobbyUnsubscribe();
        currentLobbyId = null;
        currentPage = 'menu';
        render();
      } catch (error) {
        console.error('Error leaving lobby:', error);
        currentPage = 'menu';
        render();
      }
    }

    async function startMultiplayerGame() {
      try {
        if (!currentLobbyId || !gameData) return;
        
        const lobbyRef = doc(db, 'lobbies', currentLobbyId);
        let newGameData;
        
        if (gameData.gameType === GAME_TYPES.POKER) {
          newGameData = await initializePokerGame(gameData.players, true);
        } else if (gameData.gameType === GAME_TYPES.STRATEGY) {
          newGameData = await initializeStrategyGame(gameData.players, true);
        } else if (gameData.gameType === GAME_TYPES.BULLSHIT) {
          newGameData = await initializeBullshitGame(gameData.players, true);
        } else if (gameData.gameType === GAME_TYPES.SPADES) {
          newGameData = await initializeSpadesGame(gameData.players, true);
        }
        
        // Update lobby to starting status with game data
        await updateDoc(lobbyRef, {
          status: 'starting',
          gameData: newGameData
        });
        
        // Create actual game document
        await setDoc(doc(db, 'games', currentLobbyId), newGameData);
      } catch (error) {
        console.error('Error starting game:', error);
        alert('Failed to start game. Please try again.');
      }
    }

    function subscribeToGame(gId) {
      const gameRef = doc(db, 'games', gId);
      unsubscribe = onSnapshot(gameRef, (snapshot) => {
        if (snapshot.exists()) {
          gameData = snapshot.data();
          
          if (gameData.type === GAME_TYPES.POKER) {
            console.log('Poker game update received:', {
              round: gameData.round,
              communityCards: gameData.communityCards,
              communityCardsLength: gameData.communityCards?.length || 0,
              isMultiplayer: gameData.isMultiplayer,
              turnIndex: gameData.turnIndex,
              actionStartIndex: gameData.actionStartIndex,
              currentPlayerIndex: ((gameData.actionStartIndex || 0) + gameData.turnIndex) % gameData.players.length,
              currentPlayerId: gameData.players[((gameData.actionStartIndex || 0) + gameData.turnIndex) % gameData.players.length]?.id,
              myId: currentUser.uid,
              isMyTurn: gameData.players[((gameData.actionStartIndex || 0) + gameData.turnIndex) % gameData.players.length]?.id === currentUser.uid
            });
          }
          
          render();
          
          // Run AI if needed
          if (gameData.type === GAME_TYPES.STRATEGY && gameData.turn === 'ai') {
            runStrategyAI();
          }
          if (gameData.type === GAME_TYPES.POKER) {
            // Only check round advance automatically in single-player
            // In multiplayer, it's called explicitly after each action
            if (!gameData.isMultiplayer) {
              setTimeout(() => {
                if (gameData && gameData.type === GAME_TYPES.POKER) {
                  checkPokerRoundAdvance();
                  if (isAITurn()) {
                    runPokerAI();
                  }
                }
              }, 100);
            }
          }
          if (gameData.type === GAME_TYPES.BULLSHIT) {
            // Handle BS timer in multiplayer - only schedule once per claim
            if (gameData.canCallBS && gameData.bsTimer) {
              const elapsed = Date.now() - gameData.bsTimer;
              const remaining = 3000 - elapsed;
              
              // Only schedule if we haven't already and timer hasn't expired
              if (remaining > 0 && !window.bsTimerScheduled) {
                window.bsTimerScheduled = true;
                
                // Schedule auto-close of BS window
                setTimeout(() => {
                  // Only close if still the same claim (check timestamp)
                  if (gameData.canCallBS && gameData.bsTimer && gameId) {
                    const currentElapsed = Date.now() - gameData.bsTimer;
                    if (currentElapsed >= 3000) {
                      updateDoc(doc(db, 'games', gameId), { canCallBS: false }).then(() => {
                        window.bsTimerScheduled = false;
                      }).catch(err => {
                        console.error('Error closing BS window:', err);
                        window.bsTimerScheduled = false;
                      });
                    }
                  }
                }, remaining);
              }
            } else {
              // Clear the flag when BS window is closed
              window.bsTimerScheduled = false;
            }
            
            // Run AI if single player
            if (!gameData.isMultiplayer && gameData.turn !== currentUser.uid) {
              runBullshitAI();
            }
          }
          if (gameData.type === GAME_TYPES.SPADES) {
            // Run AI if single player
            if (!gameData.isMultiplayer && gameData.turn !== currentUser.uid) {
              runSpadesAI();
            }
          }
        }
      });
    }

    async function initializePokerGame(players, isMulti) {
      const deck = generateDeck();
      const rank = getRank(userStats.totalWins);

      const playerStates = {};
      players.forEach((p, i) => {
        playerStates[p.id] = {
          chips: p.id === currentUser.uid ? userStats.totalChips : 2000,
          cards: deck.splice(i * 2, 2),
          contribution: 0,
          folded: false,
          isAllIn: false,
          raisesThisRound: 0
        };
      });

      const logs = ['Neural link established.'];
      if (players.some(p => p.id === currentUser.uid)) {
        logs.push(`üí∞ Starting balance: $${userStats.totalChips} chips`);
        if (rank !== 'Recruit') {
          logs.push(`üéñÔ∏è Current Rank: ${rank}`);
        }
      }
      
      if (isMulti) {
        logs.push(`üåê Multiplayer game - ${players.length} players connected`);
      }

      const dealerIndex = 0;
      const smallBlind = 10;
      const bigBlind = 20;
      
      let sbIndex, bbIndex, actionStartIndex;
      
      if (players.length === 2) {
        // Heads-up: Dealer is Small Blind, other player is Big Blind
        // Dealer acts first pre-flop
        sbIndex = dealerIndex;
        bbIndex = (dealerIndex + 1) % 2;
        actionStartIndex = dealerIndex;  // Dealer (SB) acts first
      } else {
        // 3+ players: Normal blind structure
        sbIndex = (dealerIndex + 1) % players.length;
        bbIndex = (dealerIndex + 2) % players.length;
        actionStartIndex = (bbIndex + 1) % players.length;  // After BB
      }
      
      const sbPlayer = players[sbIndex];
      const bbPlayer = players[bbIndex];
      if (playerStates[sbPlayer.id]) {
        playerStates[sbPlayer.id].contribution = smallBlind;
        playerStates[sbPlayer.id].chips -= smallBlind;
      }
      if (playerStates[bbPlayer.id]) {
        playerStates[bbPlayer.id].contribution = bigBlind;
        playerStates[bbPlayer.id].chips -= bigBlind;
      }
      logs.push(`Blind cycle: SB $${smallBlind}, BB $${bigBlind}`);
      
      return {
        type: GAME_TYPES.POKER,
        players,
        playerStates,
        deck,
        communityCards: [],
        pot: smallBlind + bigBlind,
        currentBet: bigBlind,
        round: 'pre-flop',
        turnIndex: 0,
        actionStartIndex: actionStartIndex,
        expectedActorId: players[actionStartIndex].id,
        dealerIndex,
        status: 'playing',
        logs,
        isMultiplayer: isMulti
      };
    }

    async function initializeStrategyGame(players, isMulti) {
      const gridSize = 8;
      const initialGrid = Array(gridSize * gridSize).fill(null).map((_, i) => ({
        id: i,
        x: i % gridSize,
        y: Math.floor(i / gridSize),
        owner: null,
        strength: 0
      }));
      
      const rank = getRank(userStats.totalWins);
      let startingEnergy = 10;
      
      if (rank === 'Specialist' || rank === 'Vanguard' || rank === 'Veteran' || rank === 'Master' || rank === 'Legend') {
        startingEnergy = Math.floor(startingEnergy * 1.1);
      }
      if (rank === 'Master' || rank === 'Legend') {
        startingEnergy = Math.floor(startingEnergy * 1.15);
      }
      
      // Starting positions for up to 8 players (corners and edges)
      const startPositions = [
        0,                          // Top-left
        gridSize - 1,               // Top-right
        (gridSize * gridSize) - gridSize, // Bottom-left
        (gridSize * gridSize) - 1,  // Bottom-right
        Math.floor(gridSize / 2),   // Top-middle
        (gridSize * gridSize) - Math.floor(gridSize / 2) - 1, // Bottom-middle
        Math.floor(gridSize / 2) * gridSize, // Left-middle
        Math.floor(gridSize / 2) * gridSize + gridSize - 1 // Right-middle
      ];
      
      // Assign starting positions to each player
      const playerEnergy = {};
      players.forEach((player, index) => {
        const pos = startPositions[index];
        initialGrid[pos].owner = player.id;
        initialGrid[pos].strength = 5;
        playerEnergy[player.id] = player.id === currentUser.uid ? startingEnergy : 10;
      });
      
      const logs = ['Strategic takeover initiated. Eliminate all opponents to win.'];
      if (rank !== 'Recruit' && players.some(p => p.id === currentUser.uid)) {
        logs.push(`üéñÔ∏è Rank Bonus: ${rank} - Starting with ${startingEnergy} energy`);
      }
      if (isMulti) {
        logs.push(`üåê Multiplayer game - ${players.length} players connected`);
      }
      
      return {
        type: GAME_TYPES.STRATEGY,
        status: 'playing',
        currentTurn: players[0].id,
        players,
        grid: initialGrid,
        playerEnergy,
        gridSize,
        logs
      };
    }

    // Game Logic
    async function startStrategyGame() {
      const gridSize = 8;
      const initialGrid = Array(gridSize * gridSize).fill(null).map((_, i) => ({
        id: i,
        x: i % gridSize,
        y: Math.floor(i / gridSize),
        owner: null,
        strength: 0
      }));
      
      // Apply rank bonuses
      const rank = getRank(userStats.totalWins);
      let startingEnergy = 10;
      let extraNodes = 0;
      
      // Specialist: +10% starting energy
      if (rank === 'Specialist' || rank === 'Vanguard' || rank === 'Veteran' || rank === 'Master' || rank === 'Legend') {
        startingEnergy = Math.floor(startingEnergy * 1.1);
      }
      
      // Master & Legend: Additional +15% energy
      if (rank === 'Master' || rank === 'Legend') {
        startingEnergy = Math.floor(startingEnergy * 1.15);
      }
      
      // Veteran, Master, Legend: +2 starting nodes
      if (rank === 'Veteran' || rank === 'Master' || rank === 'Legend') {
        extraNodes = 2;
      }
      
      // Set up starting nodes
      initialGrid[0].owner = 'player';
      initialGrid[0].strength = 5;
      initialGrid[(gridSize * gridSize) - 1].owner = 'ai';
      initialGrid[(gridSize * gridSize) - 1].strength = 5;
      
      // Add extra starting nodes based on rank
      if (extraNodes > 0) {
        const playerAdjacentIndices = [1, gridSize]; // Adjacent to player start
        for (let i = 0; i < Math.min(extraNodes, playerAdjacentIndices.length); i++) {
          const idx = playerAdjacentIndices[i];
          initialGrid[idx].owner = 'player';
          initialGrid[idx].strength = 3;
        }
      }
      
      const logs = ['Strategic takeover initiated. Capture all nodes to win.'];
      if (rank !== 'Recruit') {
        logs.push(`üéñÔ∏è Rank Bonus: ${rank} - Starting with ${startingEnergy} energy${extraNodes > 0 ? ` and ${extraNodes} extra nodes` : ''}`);
      }
      
      gameData = {
        type: GAME_TYPES.STRATEGY,
        status: 'playing',
        turn: 'player',
        grid: initialGrid,
        energy: startingEnergy,
        aiEnergy: 10,
        gridSize,
        logs
      };

      selectedStrategyNode = null;
      currentPage = 'game';
      render();
    }

    // ========================================
    // BULLSHIT GAME
    // ========================================
    
    let bullshitAIPlayerCount = 3;
    
    async function initializeBullshitGame(players, isMulti) {
      const deck = generateDeck();
      const hands = {};
      const cardsPerPlayer = Math.floor(52 / players.length);
      
      // Deal cards
      players.forEach((player, i) => {
        const hand = deck.splice(0, cardsPerPlayer);
        
        // Sort by suit (Spades, Hearts, Diamonds, Clubs) then by rank
        const suitOrder = { '‚ô†': 0, '‚ô•': 1, '‚ô¶': 2, '‚ô£': 3 };
        const rankOrder = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };
        
        hand.sort((a, b) => {
          if (suitOrder[a.suit] !== suitOrder[b.suit]) {
            return suitOrder[a.suit] - suitOrder[b.suit];
          }
          return rankOrder[a.rank] - rankOrder[b.rank];
        });
        
        hands[player.id] = hand;
      });
      
      // Remaining cards go in the pile (shouldn't happen with standard player counts)
      const pile = deck;
      
      return {
        type: GAME_TYPES.BULLSHIT,
        players,
        hands,
        pile,
        currentRank: '2', // Start with 2s
        currentPlayerIndex: 0,
        lastClaim: null, // { playerId, rank, count, cards }
        status: 'playing',
        logs: ['Game started! First player must play 2s.'],
        turn: players[0].id,
        isMultiplayer: isMulti
      };
    }
    
    async function startBullshitGame() {
      const aiCount = isMultiplayer ? 0 : bullshitAIPlayerCount;
      const aiNames = ['Bluff-Bot', 'Truth-Teller', 'Wild-Card', 'Poker-Face', 'Lucky-Liar'];
      const aiAvatars = ['ü§•', 'üòá', 'üÉè', 'üòé', 'üçÄ'];
      
      const aiPlayers = Array.from({ length: aiCount }, (_, i) => ({
        id: `ai-${i + 1}`,
        name: aiNames[i] || `AI-${i + 1}`,
        isAI: true,
        avatar: aiAvatars[i] || 'ü§ñ'
      }));
      
      const players = [
        { id: currentUser.uid, name: currentUser.displayName || 'You', isAI: false, avatar: userStats.avatar || 'üë§' },
        ...aiPlayers
      ];
      
      const gameDataInit = await initializeBullshitGame(players, false);
      gameData = gameDataInit;
      currentPage = 'game';
      render();
      
      // Start AI if it's their turn
      if (gameData.turn !== currentUser.uid) {
        setTimeout(() => runBullshitAI(), 1500);
      }
    }
    
    function getBullshitNextRank(currentRank) {
      const rankOrder = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
      const currentIndex = rankOrder.indexOf(currentRank);
      return rankOrder[(currentIndex + 1) % rankOrder.length];
    }
    
    function handleBullshitPlay(selectedCards, claimedRank) {
      if (!gameData || gameData.status !== 'playing') return;
      if (gameData.turn !== currentUser.uid) return;
      if (!selectedCards || selectedCards.length === 0) return;
      
      const playerHand = gameData.hands[currentUser.uid];
      
      // Remove played cards from hand
      const newHands = { ...gameData.hands };
      newHands[currentUser.uid] = playerHand.filter(card => 
        !selectedCards.some(sc => sc.suit === card.suit && sc.rank === card.rank)
      );
      
      // Add cards to pile
      const newPile = [...gameData.pile, ...selectedCards];
      
      // Record the claim
      const claim = {
        playerId: currentUser.uid,
        playerName: currentUser.displayName || 'You',
        rank: claimedRank,
        count: selectedCards.length,
        cards: selectedCards,
        timestamp: Date.now()
      };
      
      // Move to next player
      const nextPlayerIndex = (gameData.currentPlayerIndex + 1) % gameData.players.length;
      const nextPlayer = gameData.players[nextPlayerIndex];
      
      const updates = {
        hands: newHands,
        pile: newPile,
        lastClaim: claim,
        currentPlayerIndex: nextPlayerIndex,
        turn: nextPlayer.id,
        currentRank: getBullshitNextRank(claimedRank),
        logs: [...gameData.logs, `${claim.playerName} claimed ${claim.count} ${claimedRank}${claim.count > 1 ? 's' : ''}`],
        canCallBS: true,
        bsTimer: Date.now()
      };
      
      // Check if player won
      if (newHands[currentUser.uid].length === 0) {
        updates.status = 'ended';
        updates.winner = currentUser.uid;
        updates.canCallBS = false;
        updates.logs = [...updates.logs, `üéâ ${currentUser.displayName || 'You'} won!`];
        
        if (!gameData.isMultiplayer) {
          updateStats({
            bullshitWins: (userStats.bullshitWins || 0) + 1,
            totalWins: userStats.totalWins + 1,
            gamesPlayed: userStats.gamesPlayed + 1
          });
        }
      }
      
      // Sync with Firebase if multiplayer, otherwise just update local state
      if (gameData.isMultiplayer && gameId) {
        updateDoc(doc(db, 'games', gameId), updates).catch(err => {
          console.error('Error updating game:', err);
        });
      } else {
        updateGameState(updates);
        
        // Give 3 seconds for anyone to call BS before AI continues
        if (!updates.status || updates.status === 'playing') {
          setTimeout(() => {
            if (gameData.canCallBS && gameData.turn !== currentUser.uid) {
              updateGameState({ canCallBS: false });
              setTimeout(() => runBullshitAI(), 500);
            }
          }, 3000);
        }
      }
    }
    
    function handleBullshitCall() {
      if (!gameData || !gameData.lastClaim || !gameData.canCallBS) return;
      
      const claim = gameData.lastClaim;
      const actualRanks = claim.cards.map(c => c.rank);
      const wasLying = !actualRanks.every(r => r === claim.rank);
      
      const callerName = currentUser.displayName || 'You';
      const callerId = currentUser.uid;
      
      // Show what was actually played
      const actualCardsText = claim.cards.map(c => `${c.rank}${c.suit}`).join(', ');
      
      let newHands = { ...gameData.hands };
      let logs = [...gameData.logs];
      
      if (wasLying) {
        // Caller was right! Liar takes the pile
        logs.push(`üö® ${callerName} called BS!`);
        logs.push(`${claim.playerName} actually played: ${actualCardsText}`);
        logs.push(`${claim.playerName} was LYING! Takes ${gameData.pile.length} cards.`);
        newHands[claim.playerId] = [...newHands[claim.playerId], ...gameData.pile];
      } else {
        // Caller was wrong! Caller takes the pile
        logs.push(`üö® ${callerName} called BS!`);
        logs.push(`${claim.playerName} actually played: ${actualCardsText}`);
        logs.push(`${claim.playerName} was telling the TRUTH! ${callerName} takes ${gameData.pile.length} cards.`);
        newHands[callerId] = [...newHands[callerId], ...gameData.pile];
      }
      
      // Find who takes next turn (person after the one who took pile)
      const penalizedId = wasLying ? claim.playerId : callerId;
      const penalizedIndex = gameData.players.findIndex(p => p.id === penalizedId);
      const nextPlayerIndex = (penalizedIndex + 1) % gameData.players.length;
      const nextPlayer = gameData.players[nextPlayerIndex];
      
      const updates = {
        hands: newHands,
        pile: [],
        lastClaim: null,
        currentPlayerIndex: nextPlayerIndex,
        turn: nextPlayer.id,
        logs,
        canCallBS: false
      };
      
      // Sync with Firebase if multiplayer, otherwise just update local state
      if (gameData.isMultiplayer && gameId) {
        updateDoc(doc(db, 'games', gameId), updates).catch(err => {
          console.error('Error updating game:', err);
        });
      } else {
        updateGameState(updates);
        
        setTimeout(() => {
          if (gameData.turn !== currentUser.uid) {
            runBullshitAI();
          }
        }, 1000);
      }
    }
    
    function runBullshitAI() {
      if (!gameData || gameData.status !== 'playing') return;
      if (gameData.turn === currentUser.uid) return;
      
      const currentPlayer = gameData.players[gameData.currentPlayerIndex];
      if (!currentPlayer || !currentPlayer.isAI) return;
      
      setTimeout(() => {
        const aiHand = gameData.hands[currentPlayer.id];
        const requiredRank = gameData.currentRank;
        
        // If there's a lastClaim and BS can still be called, AI might call BS
        if (gameData.lastClaim && gameData.canCallBS && Math.random() < 0.25) {
          const claim = gameData.lastClaim;
          const suspicionLevel = claim.count >= 3 ? 0.6 : 0.3;
          
          if (Math.random() < suspicionLevel) {
            // AI calls BS
            const wasLying = !claim.cards.every(c => c.rank === claim.rank);
            const actualCardsText = claim.cards.map(c => `${c.rank}${c.suit}`).join(', ');
            
            let newHands = { ...gameData.hands };
            let logs = [...gameData.logs];
            
            if (wasLying) {
              logs.push(`üö® ${currentPlayer.name} called BS!`);
              logs.push(`${claim.playerName} actually played: ${actualCardsText}`);
              logs.push(`${claim.playerName} was LYING! Takes ${gameData.pile.length} cards.`);
              newHands[claim.playerId] = [...newHands[claim.playerId], ...gameData.pile];
            } else {
              logs.push(`üö® ${currentPlayer.name} called BS!`);
              logs.push(`${claim.playerName} actually played: ${actualCardsText}`);
              logs.push(`${claim.playerName} was telling the TRUTH! ${currentPlayer.name} takes ${gameData.pile.length} cards.`);
              newHands[currentPlayer.id] = [...newHands[currentPlayer.id], ...gameData.pile];
            }
            
            const penalizedId = wasLying ? claim.playerId : currentPlayer.id;
            const penalizedIndex = gameData.players.findIndex(p => p.id === penalizedId);
            const nextPlayerIndex = (penalizedIndex + 1) % gameData.players.length;
            const nextPlayer = gameData.players[nextPlayerIndex];
            
            updateGameState({
              hands: newHands,
              pile: [],
              lastClaim: null,
              currentPlayerIndex: nextPlayerIndex,
              turn: nextPlayer.id,
              logs,
              canCallBS: false
            });
            
            setTimeout(() => runBullshitAI(), 1000);
            return;
          }
        }
        
        // Don't play if BS can still be called (wait for window to close)
        if (gameData.canCallBS) {
          setTimeout(() => runBullshitAI(), 500);
          return;
        }
        
        // AI plays cards
        const matchingCards = aiHand.filter(c => c.rank === requiredRank);
        let cardsToPlay = [];
        
        if (matchingCards.length > 0) {
          // Play honestly (most of the time)
          const playCount = Math.min(matchingCards.length, Math.random() < 0.7 ? 1 : 2);
          cardsToPlay = matchingCards.slice(0, playCount);
        } else {
          // Must lie
          const playCount = Math.random() < 0.6 ? 1 : 2;
          cardsToPlay = aiHand.slice(0, Math.min(playCount, aiHand.length));
        }
        
        const newHands = { ...gameData.hands };
        newHands[currentPlayer.id] = aiHand.filter(card => 
          !cardsToPlay.some(pc => pc.suit === card.suit && pc.rank === card.rank)
        );
        
        const newPile = [...gameData.pile, ...cardsToPlay];
        const claim = {
          playerId: currentPlayer.id,
          playerName: currentPlayer.name,
          rank: requiredRank,
          count: cardsToPlay.length,
          cards: cardsToPlay,
          timestamp: Date.now()
        };
        
        const nextPlayerIndex = (gameData.currentPlayerIndex + 1) % gameData.players.length;
        const nextPlayer = gameData.players[nextPlayerIndex];
        
        updateGameState({
          hands: newHands,
          pile: newPile,
          lastClaim: claim,
          currentPlayerIndex: nextPlayerIndex,
          turn: nextPlayer.id,
          currentRank: getBullshitNextRank(requiredRank),
          logs: [...gameData.logs, `${claim.playerName} claimed ${claim.count} ${requiredRank}${claim.count > 1 ? 's' : ''}`],
          canCallBS: true,
          bsTimer: Date.now()
        });
        
        // Check if AI won
        if (newHands[currentPlayer.id].length === 0) {
          updateGameState({
            status: 'ended',
            winner: currentPlayer.id,
            canCallBS: false,
            logs: [...gameData.logs, `üéâ ${currentPlayer.name} won!`]
          });
          updateStats({
            gamesPlayed: userStats.gamesPlayed + 1
          });
          return;
        }
        
        // Give 3 seconds for player to call BS
        setTimeout(() => {
          if (gameData.canCallBS) {
            updateGameState({ canCallBS: false });
            setTimeout(() => runBullshitAI(), 500);
          }
        }, 3000);
      }, 1000);
    }

    // ========================================
    // SPADES GAME
    // ========================================
    
    async function initializeSpadesGame(players, isMulti) {
      // Spades requires exactly 4 players
      if (players.length !== 4) {
        throw new Error('Spades requires exactly 4 players');
      }
      
      const deck = generateDeck();
      const hands = {};
      
      // Deal 13 cards to each player
      players.forEach((player, i) => {
        hands[player.id] = deck.splice(0, 13).sort((a, b) => {
          const suitOrder = { '‚ô†': 0, '‚ô•': 1, '‚ô¶': 2, '‚ô£': 3 };
          const rankOrder = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };
          if (suitOrder[a.suit] !== suitOrder[b.suit]) return suitOrder[a.suit] - suitOrder[b.suit];
          return rankOrder[a.rank] - rankOrder[b.rank];
        });
      });
      
      // Partnerships: 0-2 (player 0 and 2), 1-3 (player 1 and 3)
      const partnerships = {
        team1: [players[0].id, players[2].id],
        team2: [players[1].id, players[3].id]
      };
      
      return {
        type: GAME_TYPES.SPADES,
        players,
        hands,
        partnerships,
        bids: {},
        tricks: 0,
        currentTrick: [],
        currentPlayerIndex: 0,
        turn: players[0].id,
        leadingSuit: null,
        scores: { team1: 0, team2: 0 },
        bags: { team1: 0, team2: 0 },
        tricksWon: {},
        phase: 'bidding',
        status: 'playing',
        logs: ['Game started! Place your bids.'],
        isMultiplayer: isMulti,
        round: 1
      };
    }
    
    async function startSpadesGame() {
      const aiCount = isMultiplayer ? 0 : 3;
      const aiNames = ['North AI', 'East AI', 'South AI'];
      const aiAvatars = ['üß≠', 'üåÖ', 'üèúÔ∏è'];
      
      const aiPlayers = Array.from({ length: aiCount }, (_, i) => ({
        id: `ai-${i + 1}`,
        name: aiNames[i] || `AI-${i + 1}`,
        isAI: true,
        avatar: aiAvatars[i] || 'ü§ñ'
      }));
      
      const players = [
        { id: currentUser.uid, name: currentUser.displayName || 'You', isAI: false, avatar: userStats.avatar || 'üë§' },
        ...aiPlayers
      ];
      
      const gameDataInit = await initializeSpadesGame(players, false);
      gameData = gameDataInit;
      currentPage = 'game';
      render();
      
      // Start AI bidding if needed
      if (gameData.turn !== currentUser.uid && gameData.phase === 'bidding') {
        setTimeout(() => runSpadesAI(), 1500);
      }
    }
    
    function handleSpadesBid(bidAmount) {
      if (!gameData || gameData.phase !== 'bidding') return;
      if (gameData.turn !== currentUser.uid) return;
      
      const newBids = { ...gameData.bids };
      newBids[currentUser.uid] = bidAmount;
      
      const nextPlayerIndex = (gameData.currentPlayerIndex + 1) % gameData.players.length;
      const nextPlayer = gameData.players[nextPlayerIndex];
      
      const updates = {
        bids: newBids,
        currentPlayerIndex: nextPlayerIndex,
        turn: nextPlayer.id,
        logs: [...gameData.logs, `${currentUser.displayName || 'You'} bid ${bidAmount} trick${bidAmount !== 1 ? 's' : ''}`]
      };
      
      // Check if all bids are in
      if (Object.keys(newBids).length === 4) {
        updates.phase = 'playing';
        updates.logs = [...updates.logs, 'All bids placed! Game begins.'];
        
        // Initialize tricks won
        const tricksWon = {};
        gameData.players.forEach(p => tricksWon[p.id] = 0);
        updates.tricksWon = tricksWon;
      }
      
      if (gameData.isMultiplayer && gameId) {
        updateDoc(doc(db, 'games', gameId), updates).catch(err => {
          console.error('Error updating game:', err);
        });
      } else {
        updateGameState(updates);
        
        if (updates.phase === 'playing') {
          setTimeout(() => runSpadesAI(), 1000);
        } else if (gameData.turn !== currentUser.uid) {
          setTimeout(() => runSpadesAI(), 1000);
        }
      }
    }
    
    function handleSpadesPlay(card) {
      if (!gameData || gameData.phase !== 'playing') return;
      if (gameData.turn !== currentUser.uid) return;
      
      const playerHand = gameData.hands[currentUser.uid];
      const currentTrick = gameData.currentTrick || [];
      
      // Validate play
      if (!canPlayCard(card, playerHand, currentTrick, gameData.leadingSuit)) {
        alert('You must follow suit if possible!');
        return;
      }
      
      // Remove card from hand
      const newHands = { ...gameData.hands };
      newHands[currentUser.uid] = playerHand.filter(c => !(c.suit === card.suit && c.rank === card.rank));
      
      // Add to current trick
      const newTrick = [...currentTrick, { playerId: currentUser.uid, card }];
      
      const nextPlayerIndex = (gameData.currentPlayerIndex + 1) % gameData.players.length;
      const nextPlayer = gameData.players[nextPlayerIndex];
      
      let updates = {
        hands: newHands,
        currentTrick: newTrick,
        currentPlayerIndex: nextPlayerIndex,
        turn: nextPlayer.id,
        logs: [...gameData.logs, `${currentUser.displayName || 'You'} played ${card.rank}${card.suit}`]
      };
      
      // Set leading suit if first card
      if (currentTrick.length === 0) {
        updates.leadingSuit = card.suit;
      }
      
      // Check if trick is complete
      if (newTrick.length === 4) {
        const winner = determineTrickWinner(newTrick, updates.leadingSuit);
        const winnerPlayer = gameData.players.find(p => p.id === winner);
        
        const newTricksWon = { ...gameData.tricksWon };
        newTricksWon[winner] = (newTricksWon[winner] || 0) + 1;
        
        updates.tricksWon = newTricksWon;
        updates.tricks = (gameData.tricks || 0) + 1;
        updates.logs = [...updates.logs, `${winnerPlayer.name} wins the trick!`];
        updates.currentTrick = [];
        updates.leadingSuit = null;
        
        // Find winner's index for next turn
        const winnerIndex = gameData.players.findIndex(p => p.id === winner);
        updates.currentPlayerIndex = winnerIndex;
        updates.turn = winner;
        
        // Check if round is over (13 tricks)
        if (updates.tricks === 13) {
          // Use updated game state for scoring
          const gameStateForScoring = { ...gameData, ...updates };
          const scores = calculateSpadesScores(gameStateForScoring);
          updates.scores = scores.scores;
          updates.bags = scores.bags;
          updates.logs = [...updates.logs, ...scores.logs];
          
          // Check for winner (500 points)
          if (scores.scores.team1 >= 500 || scores.scores.team2 >= 500) {
            const winningTeam = scores.scores.team1 >= scores.scores.team2 ? 'team1' : 'team2';
            updates.status = 'ended';
            updates.winner = winningTeam;
            updates.logs = [...updates.logs, `üéâ ${winningTeam === 'team1' ? 'Team 1' : 'Team 2'} wins the game!`];
            
            if (!gameData.isMultiplayer) {
              const isPlayerTeam1 = gameData.partnerships.team1.includes(currentUser.uid);
              const playerWon = (isPlayerTeam1 && winningTeam === 'team1') || 
                               (!isPlayerTeam1 && winningTeam === 'team2');
              
              if (playerWon) {
                updateStats({
                  spadesWins: (userStats.spadesWins || 0) + 1,
                  totalWins: userStats.totalWins + 1,
                  gamesPlayed: userStats.gamesPlayed + 1
                });
              } else {
                updateStats({
                  gamesPlayed: userStats.gamesPlayed + 1
                });
              }
            }
          } else {
            // Start new round
            updates = startNewSpadesRound(updates);
          }
        }
      }
      
      if (gameData.isMultiplayer && gameId) {
        updateDoc(doc(db, 'games', gameId), updates).catch(err => {
          console.error('Error updating game:', err);
        });
      } else {
        updateGameState(updates);
        
        if (updates.status !== 'ended' && updates.turn !== currentUser.uid) {
          setTimeout(() => runSpadesAI(), 1000);
        }
      }
    }
    
    function canPlayCard(card, hand, currentTrick, leadingSuit) {
      // First card of trick - can play anything
      if (currentTrick.length === 0) return true;
      
      // Must follow suit if possible
      const hasSuit = hand.some(c => c.suit === leadingSuit);
      if (hasSuit) {
        return card.suit === leadingSuit;
      }
      
      // Can play any card if can't follow suit
      return true;
    }
    
    function determineTrickWinner(trick, leadingSuit) {
      let winningPlay = trick[0];
      
      for (let i = 1; i < trick.length; i++) {
        const currentPlay = trick[i];
        
        // Spades always win
        if (currentPlay.card.suit === '‚ô†' && winningPlay.card.suit !== '‚ô†') {
          winningPlay = currentPlay;
        } else if (currentPlay.card.suit === '‚ô†' && winningPlay.card.suit === '‚ô†') {
          // Both spades, higher wins
          if (getCardValue(currentPlay.card) > getCardValue(winningPlay.card)) {
            winningPlay = currentPlay;
          }
        } else if (winningPlay.card.suit !== '‚ô†' && currentPlay.card.suit === leadingSuit) {
          // Neither spades, must match leading suit and be higher
          if (winningPlay.card.suit !== leadingSuit || getCardValue(currentPlay.card) > getCardValue(winningPlay.card)) {
            winningPlay = currentPlay;
          }
        }
      }
      
      return winningPlay.playerId;
    }
    
    function getCardValue(card) {
      const values = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };
      return values[card.rank];
    }
    
    function calculateSpadesScores(gameData) {
      const { bids, tricksWon, partnerships, scores, bags } = gameData;
      
      const newScores = { ...scores };
      const newBags = { ...bags };
      const logs = [];
      
      // Calculate team tricks
      const team1Tricks = partnerships.team1.reduce((sum, pid) => sum + (tricksWon[pid] || 0), 0);
      const team2Tricks = partnerships.team2.reduce((sum, pid) => sum + (tricksWon[pid] || 0), 0);
      
      const team1Bid = partnerships.team1.reduce((sum, pid) => sum + (bids[pid] || 0), 0);
      const team2Bid = partnerships.team2.reduce((sum, pid) => sum + (bids[pid] || 0), 0);
      
      // Team 1 scoring
      if (team1Tricks >= team1Bid) {
        newScores.team1 += team1Bid * 10;
        const overtricks = team1Tricks - team1Bid;
        newScores.team1 += overtricks;
        newBags.team1 += overtricks;
        logs.push(`Team 1: Made bid! +${team1Bid * 10} points, ${overtricks} bag${overtricks !== 1 ? 's' : ''}`);
      } else {
        newScores.team1 -= team1Bid * 10;
        logs.push(`Team 1: Set! -${team1Bid * 10} points`);
      }
      
      // Team 2 scoring
      if (team2Tricks >= team2Bid) {
        newScores.team2 += team2Bid * 10;
        const overtricks = team2Tricks - team2Bid;
        newScores.team2 += overtricks;
        newBags.team2 += overtricks;
        logs.push(`Team 2: Made bid! +${team2Bid * 10} points, ${overtricks} bag${overtricks !== 1 ? 's' : ''}`);
      } else {
        newScores.team2 -= team2Bid * 10;
        logs.push(`Team 2: Set! -${team2Bid * 10} points`);
      }
      
      // Bag penalty (10 bags = -100 points)
      if (newBags.team1 >= 10) {
        newScores.team1 -= 100;
        newBags.team1 -= 10;
        logs.push(`Team 1: 10 bags! -100 points`);
      }
      if (newBags.team2 >= 10) {
        newScores.team2 -= 100;
        newBags.team2 -= 10;
        logs.push(`Team 2: 10 bags! -100 points`);
      }
      
      logs.push(`Scores - Team 1: ${newScores.team1}, Team 2: ${newScores.team2}`);
      
      return { scores: newScores, bags: newBags, logs };
    }
    
    function startNewSpadesRound(updates) {
      const deck = generateDeck();
      const newHands = {};
      
      gameData.players.forEach((player, i) => {
        newHands[player.id] = deck.splice(0, 13).sort((a, b) => {
          const suitOrder = { '‚ô†': 0, '‚ô•': 1, '‚ô¶': 2, '‚ô£': 3 };
          const rankOrder = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };
          if (suitOrder[a.suit] !== suitOrder[b.suit]) return suitOrder[a.suit] - suitOrder[b.suit];
          return rankOrder[a.rank] - rankOrder[b.rank];
        });
      });
      
      return {
        ...updates,
        hands: newHands,
        bids: {},
        tricks: 0,
        currentTrick: [],
        currentPlayerIndex: 0,
        turn: gameData.players[0].id,
        leadingSuit: null,
        tricksWon: {},
        phase: 'bidding',
        round: (gameData.round || 1) + 1,
        logs: [...updates.logs, `Round ${(gameData.round || 1) + 1} - Place your bids!`]
      };
    }
    
    function runSpadesAI() {
      if (!gameData || gameData.status !== 'playing') return;
      if (gameData.turn === currentUser.uid) return;
      
      const currentPlayer = gameData.players[gameData.currentPlayerIndex];
      if (!currentPlayer || !currentPlayer.isAI) return;
      
      setTimeout(() => {
        if (gameData.phase === 'bidding') {
          // AI bidding logic - count high cards and spades
          const hand = gameData.hands[currentPlayer.id];
          const spades = hand.filter(c => c.suit === '‚ô†').length;
          const highCards = hand.filter(c => ['A', 'K', 'Q'].includes(c.rank)).length;
          const bid = Math.max(1, Math.min(Math.floor(spades / 3) + Math.floor(highCards / 2), 13));
          
          const newBids = { ...gameData.bids };
          newBids[currentPlayer.id] = bid;
          
          const nextPlayerIndex = (gameData.currentPlayerIndex + 1) % gameData.players.length;
          const nextPlayer = gameData.players[nextPlayerIndex];
          
          const updates = {
            bids: newBids,
            currentPlayerIndex: nextPlayerIndex,
            turn: nextPlayer.id,
            logs: [...gameData.logs, `${currentPlayer.name} bid ${bid} trick${bid !== 1 ? 's' : ''}`]
          };
          
          if (Object.keys(newBids).length === 4) {
            updates.phase = 'playing';
            updates.logs = [...updates.logs, 'All bids placed! Game begins.'];
            
            const tricksWon = {};
            gameData.players.forEach(p => tricksWon[p.id] = 0);
            updates.tricksWon = tricksWon;
          }
          
          if (gameData.isMultiplayer && gameId) {
            updateDoc(doc(db, 'games', gameId), updates);
          } else {
            updateGameState(updates);
            setTimeout(() => runSpadesAI(), 1000);
          }
        } else {
          // AI playing logic - simple strategy
          const hand = gameData.hands[currentPlayer.id];
          const currentTrick = gameData.currentTrick || [];
          const leadingSuit = gameData.leadingSuit;
          
          let cardToPlay;
          
          if (currentTrick.length === 0) {
            // Leading - play lowest non-spade if possible
            const nonSpades = hand.filter(c => c.suit !== '‚ô†');
            cardToPlay = nonSpades.length > 0 ? 
              nonSpades.sort((a, b) => getCardValue(a) - getCardValue(b))[0] :
              hand.sort((a, b) => getCardValue(a) - getCardValue(b))[0];
          } else {
            // Following - try to follow suit with lowest card
            const sameSuit = hand.filter(c => c.suit === leadingSuit);
            if (sameSuit.length > 0) {
              cardToPlay = sameSuit.sort((a, b) => getCardValue(a) - getCardValue(b))[0];
            } else {
              // Can't follow suit - play lowest card
              cardToPlay = hand.sort((a, b) => getCardValue(a) - getCardValue(b))[0];
            }
          }
          
          const newHands = { ...gameData.hands };
          newHands[currentPlayer.id] = hand.filter(c => !(c.suit === cardToPlay.suit && c.rank === cardToPlay.rank));
          
          const newTrick = [...currentTrick, { playerId: currentPlayer.id, card: cardToPlay }];
          
          const nextPlayerIndex = (gameData.currentPlayerIndex + 1) % gameData.players.length;
          const nextPlayer = gameData.players[nextPlayerIndex];
          
          let updates = {
            hands: newHands,
            currentTrick: newTrick,
            currentPlayerIndex: nextPlayerIndex,
            turn: nextPlayer.id,
            logs: [...gameData.logs, `${currentPlayer.name} played ${cardToPlay.rank}${cardToPlay.suit}`]
          };
          
          if (currentTrick.length === 0) {
            updates.leadingSuit = cardToPlay.suit;
          }
          
          if (newTrick.length === 4) {
            const winner = determineTrickWinner(newTrick, updates.leadingSuit);
            const winnerPlayer = gameData.players.find(p => p.id === winner);
            
            const newTricksWon = { ...gameData.tricksWon };
            newTricksWon[winner] = (newTricksWon[winner] || 0) + 1;
            
            updates.tricksWon = newTricksWon;
            updates.tricks = (gameData.tricks || 0) + 1;
            updates.logs = [...updates.logs, `${winnerPlayer.name} wins the trick!`];
            updates.currentTrick = [];
            updates.leadingSuit = null;
            
            const winnerIndex = gameData.players.findIndex(p => p.id === winner);
            updates.currentPlayerIndex = winnerIndex;
            updates.turn = winner;
            
            if (updates.tricks === 13) {
              const scores = calculateSpadesScores(gameData);
              updates.scores = scores.scores;
              updates.bags = scores.bags;
              updates.logs = [...updates.logs, ...scores.logs];
              
              if (scores.scores.team1 >= 500 || scores.scores.team2 >= 500) {
                updates.status = 'ended';
                updates.winner = scores.scores.team1 >= 500 ? 'team1' : 'team2';
                updates.logs = [...updates.logs, `üéâ Team ${updates.winner === 'team1' ? '1' : '2'} wins!`];
                
                if (!gameData.isMultiplayer) {
                  updateStats({ gamesPlayed: userStats.gamesPlayed + 1 });
                }
              } else {
                updates = startNewSpadesRound(updates);
              }
            }
          }
          
          if (gameData.isMultiplayer && gameId) {
            updateDoc(doc(db, 'games', gameId), updates);
          } else {
            updateGameState(updates);
            setTimeout(() => runSpadesAI(), 1000);
          }
        }
      }, 1500);
    }

    function handleStrategyNodeClick(index) {
      // Check if it's my turn
      const isMulti = gameData.players && gameData.players.length > 1;
      const isMyTurn = isMulti ? gameData.currentTurn === currentUser.uid : gameData.turn === 'player';
      
      if (!isMyTurn || gameData.status !== 'playing') return;
      
      const node = gameData.grid[index];
      const myOwner = isMulti ? currentUser.uid : 'player';
      
      // If clicking on own node and nothing selected, select it
      if (node.owner === myOwner && selectedStrategyNode === null) {
        selectedStrategyNode = index;
        render();
        return;
      }
      
      // If clicking on own node when another is already selected, try to transfer
      if (selectedStrategyNode !== null && node.owner === myOwner) {
        const selectedNode = gameData.grid[selectedStrategyNode];
        
        // Don't transfer to the same node
        if (index === selectedStrategyNode) {
          return;
        }
        
        // Can transfer to any owned node as long as source has strength > 1
        if (selectedNode.owner === myOwner && selectedNode.strength > 1) {
          // Get transfer amount from slider if it exists, otherwise use default (70%)
          const slider = document.getElementById('transfer-slider');
          const transferAmount = slider ? parseInt(slider.value) : Math.floor(selectedNode.strength * 0.7);
          
          const newGrid = gameData.grid.map(n => {
            if (n.id === selectedNode.id) {
              return { ...n, strength: n.strength - transferAmount };
            }
            if (n.id === node.id) {
              return { ...n, strength: n.strength + transferAmount };
            }
            return n;
          });
          
          const updates = {
            grid: newGrid,
            logs: [...gameData.logs, `‚ÜîÔ∏è Transferred ${transferAmount} troops from Node ${selectedNode.id} to Node ${node.id}`]
          };
          
          if (isMulti && gameId) {
            updateDoc(doc(db, 'games', gameId), updates).catch(err => {
              console.error('Error updating game:', err);
            });
          } else {
            updateGameState(updates);
          }
          
          selectedStrategyNode = index;
          return;
        }
        
        // If can't transfer, just select the clicked node
        selectedStrategyNode = index;
        render();
        return;
      }
      
      // If we have a selection and clicked an enemy/neutral node, try to attack
      if (selectedStrategyNode !== null) {
        const neighbors = getNeighbors(selectedStrategyNode);
        
        if (neighbors.includes(index)) {
          const currentEnergy = isMulti ? (gameData.playerEnergy?.[currentUser.uid] || 0) : gameData.energy;
          
          if (currentEnergy < 2) {
            const updates = { logs: [...gameData.logs, "‚ö†Ô∏è Insufficient energy"] };
            if (isMulti && gameId) {
              updateDoc(doc(db, 'games', gameId), updates).catch(err => console.error('Error:', err));
            } else {
              updateGameState(updates);
            }
            return;
          }
          
          const newGrid = [...gameData.grid];
          const targetNode = { ...newGrid[index] };
          const sourceNode = { ...newGrid[selectedStrategyNode] };
          
          if (sourceNode.strength > targetNode.strength) {
            targetNode.owner = myOwner;
            targetNode.strength = 1;
            sourceNode.strength -= 1;
            newGrid[index] = targetNode;
            newGrid[selectedStrategyNode] = sourceNode;
            
            // Track node capture (only single-player)
            if (!isMulti) {
              updateStats({ nodesSecured: userStats.nodesSecured + 1 });
            }
            
            const updates = {
              grid: newGrid,
              logs: [...gameData.logs, `üì° Captured [${targetNode.x}, ${targetNode.y}]`]
            };
            
            if (isMulti) {
              const newEnergy = { ...gameData.playerEnergy };
              newEnergy[currentUser.uid] = (newEnergy[currentUser.uid] || 0) - 2;
              updates.playerEnergy = newEnergy;
              
              if (gameId) {
                updateDoc(doc(db, 'games', gameId), updates).catch(err => {
                  console.error('Error updating game:', err);
                });
              }
            } else {
              updates.energy = gameData.energy - 2;
              updateGameState(updates);
            }
          } else {
            targetNode.strength -= 1;
            sourceNode.strength -= 1;
            newGrid[index] = targetNode;
            newGrid[selectedStrategyNode] = sourceNode;
            
            const updates = {
              grid: newGrid,
              logs: [...gameData.logs, `üí• Attack failed at [${targetNode.x}, ${targetNode.y}]`]
            };
            
            if (isMulti) {
              const newEnergy = { ...gameData.playerEnergy };
              newEnergy[currentUser.uid] = (newEnergy[currentUser.uid] || 0) - 2;
              updates.playerEnergy = newEnergy;
              
              if (gameId) {
                updateDoc(doc(db, 'games', gameId), updates).catch(err => {
                  console.error('Error updating game:', err);
                });
              }
            } else {
              updates.energy = gameData.energy - 2;
              updateGameState(updates);
            }
          }
        }
      }
    }

    function getNeighbors(index) {
      const x = index % gameData.gridSize;
      const y = Math.floor(index / gameData.gridSize);
      const neighbors = [];
      
      if (x > 0) neighbors.push(index - 1);
      if (x < gameData.gridSize - 1) neighbors.push(index + 1);
      if (y > 0) neighbors.push(index - gameData.gridSize);
      if (y < gameData.gridSize - 1) neighbors.push(index + gameData.gridSize);
      
      return neighbors;
    }

    function runStrategyAI() {
      if (gameData.turn === 'ai' && gameData.status === 'playing') {
        setTimeout(() => {
          const newGrid = [...gameData.grid];
          let aiEnergy = gameData.aiEnergy + newGrid.filter(n => n.owner === 'ai').length;
          const aiNodes = newGrid.filter(n => n.owner === 'ai');
          const logs = [...gameData.logs];
          const borderNodes = aiNodes.filter(n => {
            const ns = getNeighbors(n.id).map(i => newGrid[i]);
            return ns.some(x => x.owner !== 'ai');
          });
          
          // Phase 1: Aggressive attacks - attack anything we can win or tie
          const attackCandidates = [];
          borderNodes.forEach(node => {
            const neighbors = getNeighbors(node.id).map(idx => newGrid[idx]);
            neighbors.forEach(t => {
              if (t.owner !== 'ai') {
                // Attack if we can win OR if it's close (more aggressive)
                if (node.strength > t.strength) {
                  // Prioritize winning attacks
                  attackCandidates.push({ s: node.id, t: t.id, m: node.strength - t.strength, priority: 2 });
                } else if (node.strength === t.strength && node.strength > 1) {
                  // Also consider even-strength attacks (risky but aggressive)
                  attackCandidates.push({ s: node.id, t: t.id, m: 0, priority: 1 });
                }
              }
            });
          });
          
          // Sort by priority (winning attacks first), then by margin
          attackCandidates.sort((a, b) => {
            if (b.priority !== a.priority) return b.priority - a.priority;
            return b.m - a.m;
          });
          
          // Attack as much as possible - use up to 80% of energy on attacks
          const maxAttacks = Math.min(attackCandidates.length, Math.floor(aiEnergy * 0.8 / 2));
          for (let i = 0; i < maxAttacks; i++) {
            const act = attackCandidates[i];
            const source = { ...newGrid[act.s] };
            const target = { ...newGrid[act.t] };
            if (aiEnergy < 2 || source.strength <= 1) break;
            
            if (source.strength > target.strength) {
              // Winning attack
              target.owner = 'ai';
              target.strength = 1;
              source.strength -= 1;
              newGrid[act.t] = target;
              newGrid[act.s] = source;
              aiEnergy -= 2;
              logs.push(`üö® AI captured [${target.x}, ${target.y}]`);
            } else {
              // Even-strength attack (mutual damage)
              target.strength -= 1;
              source.strength -= 1;
              newGrid[act.t] = target;
              newGrid[act.s] = source;
              aiEnergy -= 2;
              logs.push(`üí• AI attacked [${target.x}, ${target.y}]`);
            }
          }
          
          // Phase 2: Reinforce front lines aggressively
          // Transfer troops from strong rear nodes to weak border nodes
          const rearNodes = aiNodes.filter(n => {
            const ns = getNeighbors(n.id).map(i => newGrid[i]);
            return ns.every(x => x.owner === 'ai'); // All neighbors are AI-owned
          }).filter(n => n.strength > 2);
          
          rearNodes.sort((a, b) => b.strength - a.strength);
          const weakBorder = borderNodes.filter(n => n.strength < 3).sort((a, b) => a.strength - b.strength);
          
          rearNodes.slice(0, 3).forEach(src => {
            const closest = weakBorder
              .map(w => ({ w, d: Math.sqrt((w.x - src.x) * (w.x - src.x) + (w.y - src.y) * (w.y - src.y)) }))
              .sort((a, b) => a.d - b.d)[0];
            if (closest && newGrid[src.id].strength > 2) {
              // Transfer most of the strength (aggressive)
              const amt = Math.floor(newGrid[src.id].strength * 0.75);
              newGrid[src.id] = { ...newGrid[src.id], strength: newGrid[src.id].strength - amt };
              newGrid[closest.w.id] = { ...newGrid[closest.w.id], strength: newGrid[closest.w.id].strength + amt };
              logs.push(`‚ÜîÔ∏è AI reinforced front line with ${amt} troops`);
            }
          });
          
          // Phase 3: Spend remaining energy on border fortification
          while (aiEnergy >= 1 && borderNodes.length > 0) {
            // Prioritize nodes adjacent to player nodes
            const threats = borderNodes.filter(n => {
              const neighbors = getNeighbors(n.id).map(idx => newGrid[idx]);
              return neighbors.some(nb => nb.owner === 'player');
            });
            
            const fortifyTarget = (threats.length > 0 ? threats : borderNodes)
              .sort((a, b) => a.strength - b.strength)[0];
            
            if (!fortifyTarget) break;
            newGrid[fortifyTarget.id].strength += 1;
            aiEnergy -= 1;
          }
          
          let status = 'playing';
          if (newGrid.filter(n => n.owner === 'player').length === 0) {
            status = 'gameover';
            updateStats({ gamesPlayed: userStats.gamesPlayed + 1 });
          }
          if (newGrid.filter(n => n.owner === 'ai').length === 0) {
            status = 'victory';
            updateStats({ 
              strategyWins: userStats.strategyWins + 1,
              totalWins: userStats.totalWins + 1,
              gamesPlayed: userStats.gamesPlayed + 1
            });
          }
          
          updateGameState({
            grid: newGrid,
            aiEnergy: Math.min(aiEnergy, 50),
            energy: gameData.energy + newGrid.filter(n => n.owner === 'player').length,
            turn: 'player',
            status,
            logs
          });
          
          selectedStrategyNode = null;
        }, 1000);
      }
    }

    function getNextActivePlayerIndex(fromIndex, players, states) {
      if (!players || players.length === 0) return 0;
      const len = players.length;
      for (let offset = 0; offset < len; offset++) {
        const idx = (fromIndex + offset) % len;
        const p = players[idx];
        const s = states[p.id];
        if (!s) continue;
        if (!s.folded && !s.isAllIn && s.chips > 0) {
          return idx;
        }
      }
      return fromIndex % len;
    }
    
    function enforceEligibleTurn() {
      if (!gameData || gameData.type !== GAME_TYPES.POKER || gameData.status !== 'playing') return;
      const actionStart = gameData.actionStartIndex || 0;
      const idx = (actionStart + gameData.turnIndex) % gameData.players.length;
      const p = gameData.players[idx];
      const s = gameData.playerStates?.[p.id];
      if (p?.isAI && (!s || s.folded || s.isAllIn || s.chips <= 0)) {
        updateGameState({ turnIndex: gameData.turnIndex + 1 });
      }
    }
    
    function isAITurn() {
      if (!gameData || !gameData.players) return false;
      const actionStart = gameData.actionStartIndex || 0;
      const idx = (actionStart + gameData.turnIndex) % gameData.players.length;
      const p = gameData.players[idx];
      return !!p?.isAI;
    }
    
    async function startPokerGame() {
      const aiCount = isMultiplayer ? 0 : aiPlayerCount;
      const aiNames = ['Neural-X','Deep-Logik','Cipher-Flux','Quantum-Node','Omega-Grid','Sigma-Core','Alpha-Net','Zenith-Stack'];
      const aiAvatars = ['ü§ñ', 'ü¶æ', 'üëæ', 'üéÆ', '‚ö°', 'üî•', 'üíé', 'üéØ'];
      
      const aiPlayers = Array.from({ length: aiCount }, (_, i) => ({
        id: `ai-${i + 1}`,
        name: aiNames[i] || `AI-${i + 1}`,
        isAI: true,
        avatar: aiAvatars[i] || 'ü§ñ'
      }));
      
      const players = [
        { id: currentUser.uid, name: currentUser.displayName || 'You', isAI: false, avatar: userStats.avatar || 'üë§' },
        ...aiPlayers
      ];
      
      const gameDataInit = await initializePokerGame(players, false);

      gameData = gameDataInit;
      ffActive = false;
      resolutionStarted = false;
      currentPage = 'game';
      render();
      if (isAITurn()) {
        setTimeout(() => runPokerAI(), 1000);
      }
    }

    function handlePokerAction(type, amt = 0) {
      if (!gameData || gameData.status !== 'playing' || ffActive || resolutionStarted) return;
      
      const actionStart = gameData.actionStartIndex || 0;
      const currentPlayerIndex = (actionStart + gameData.turnIndex) % gameData.players.length;
      const currentPlayer = gameData.players[currentPlayerIndex];
      if (!currentPlayer) return;
      if (!currentPlayer.isAI && aiActionGuard) return;

      const states = { ...gameData.playerStates };
      const me = states[currentPlayer.id];
      let potAdd = 0;
      let newBet = gameData.currentBet;
      let logMsg = "";
      const playerName = currentPlayer.name || currentPlayer.id;

      if (type === 'FOLD') {
        me.folded = true;
        logMsg = `${playerName} folded`;
      } else if (type === 'CALL') {
        const callNeeded = gameData.currentBet - me.contribution;
        const call = Math.min(me.chips, callNeeded);
        me.chips -= call;
        me.contribution += call;
        potAdd = call;
        if (me.chips === 0) me.isAllIn = true;
        logMsg = callNeeded === 0 ? `${playerName} checked` : `${playerName} called $${call}`;
      } else if (type === 'RAISE') {
        const r = Math.min(me.chips, amt || 20);
        newBet = gameData.currentBet + r;
        const cost = Math.min(me.chips, newBet - me.contribution);
        me.chips -= cost;
        me.contribution += cost;
        potAdd = cost;
        if (me.chips === 0) me.isAllIn = true;
        me.raisesThisRound = (me.raisesThisRound || 0) + 1;
        logMsg = `${playerName} raised to $${newBet}`;
      }

      const updates = {
        playerStates: states,
        turnIndex: gameData.turnIndex + 1,
        expectedActorId: gameData.players[((gameData.actionStartIndex || 0) + gameData.turnIndex + 1) % gameData.players.length].id,
        pot: gameData.pot + potAdd,
        currentBet: newBet,
        logs: [...(gameData.logs || []), `${logMsg}`]
      };

      if (gameData.isMultiplayer && gameId) {
        // In multiplayer, update Firebase and wait for it to complete
        updateDoc(doc(db, 'games', gameId), updates).then(() => {
          console.log('Firebase update complete, waiting for snapshot to update gameData...');
          // Wait a moment for the snapshot to update our local gameData
          setTimeout(() => {
            console.log('Now checking if round should advance...');
            checkPokerRoundAdvance();
          }, 200);
        }).catch(err => {
          console.error('Error updating game:', err);
        });
      } else {
        updateGameState(updates);
        
        setTimeout(() => {
          checkPokerRoundAdvance();
          if (isAITurn()) {
            runPokerAI();
          }
        }, 500);
      }
    }

 
    
    function getAIPersonality(name) {
      const map = {
        'Neural-X': { aggression: 0.9, bluff: 0.65, tightness: 0.3 },
        'Deep-Logik': { aggression: 0.7, bluff: 0.5, tightness: 0.5 },
        'Cipher-Flux': { aggression: 0.8, bluff: 0.6, tightness: 0.4 },
        'Quantum-Node': { aggression: 0.6, bluff: 0.55, tightness: 0.6 },
        'Omega-Grid': { aggression: 0.75, bluff: 0.5, tightness: 0.45 },
        'Sigma-Core': { aggression: 0.5, bluff: 0.4, tightness: 0.7 },
        'Alpha-Net': { aggression: 0.85, bluff: 0.7, tightness: 0.35 },
        'Zenith-Stack': { aggression: 0.7, bluff: 0.55, tightness: 0.5 }
      };
      return map[name] || { aggression: 0.6, bluff: 0.5, tightness: 0.5 };
    }
    
    let aiActionGuard = false;
    
    function runPokerAI() {
      if (!gameData || gameData.status !== 'playing' || ffActive || resolutionStarted) return;
      const actionStart = gameData.actionStartIndex || 0;
      const idx = (actionStart + gameData.turnIndex) % gameData.players.length;
      const player = gameData.players[idx];
      if (!player?.isAI) return;
      setTimeout(() => {
        const states = { ...gameData.playerStates };
        const ps = states[player.id];
        if (!ps || ps.folded || ps.isAllIn || ps.chips <= 0) {
          const nextTurn = gameData.turnIndex + 1;
          const nextActionStart = gameData.actionStartIndex || 0;
          const nextIdx = (nextActionStart + nextTurn) % gameData.players.length;
          const nextIsAI = gameData.players[nextIdx]?.isAI;
          updateGameState({ turnIndex: nextTurn });
          if (nextIsAI) {
            setTimeout(() => runPokerAI(), 300);
          }
          return;
        }
        const callNeeded = Math.max(0, gameData.currentBet - ps.contribution);
        const canCheck = callNeeded === 0;
        const handScore = evaluateHand(ps.cards, gameData.communityCards);
        const stage = gameData.communityCards.length;
        const personality = getAIPersonality(player.name);
        
        let action = 'CALL';
        let raiseInc = 0;
        const maxRaises = 2;
        const canRaise = (ps.raisesThisRound || 0) < maxRaises && ps.chips > 0;
        
        // Determine hand strength category
        let handStrength = 'weak';
        if (handScore >= 6000) handStrength = 'monster'; // Full house or better
        else if (handScore >= 4000) handStrength = 'strong'; // Straight or flush
        else if (handScore >= 2000) handStrength = 'medium'; // Two pair or three of a kind
        else if (handScore >= 1000) handStrength = 'pair'; // One pair
        
        if (canCheck) {
          // When no one has bet yet, AI should be more aggressive
          const shouldBet = Math.random() < personality.aggression;
          const shouldBluff = Math.random() < personality.bluff;
          
          if (handStrength === 'monster' && canRaise) {
            // Always bet with monster hands
            raiseInc = Math.min(ps.chips, Math.max(30, Math.floor(gameData.pot * 0.5)));
            action = 'RAISE';
          } else if (handStrength === 'strong' && canRaise && shouldBet) {
            // Usually bet with strong hands
            raiseInc = Math.min(ps.chips, Math.max(25, Math.floor(gameData.pot * 0.4)));
            action = 'RAISE';
          } else if (handStrength === 'medium' && canRaise && shouldBet && personality.aggression > 0.6) {
            // Aggressive players bet medium hands
            raiseInc = Math.min(ps.chips, Math.max(20, Math.floor(gameData.pot * 0.3)));
            action = 'RAISE';
          } else if (handStrength === 'pair' && canRaise && shouldBet && personality.aggression > 0.75) {
            // Very aggressive players bet pairs
            raiseInc = Math.min(ps.chips, Math.max(15, Math.floor(gameData.pot * 0.25)));
            action = 'RAISE';
          } else if (handStrength === 'weak' && canRaise && shouldBluff && personality.bluff > 0.6) {
            // Sometimes bluff with weak hands
            raiseInc = Math.min(ps.chips, Math.max(20, Math.floor(gameData.pot * 0.3)));
            action = 'RAISE';
          } else {
            action = 'CALL'; // Check
          }
        } else {
          // There's a bet to call
          const potOdds = callNeeded / (gameData.pot + callNeeded);
          const affordable = callNeeded <= Math.max(30, Math.floor(ps.chips * 0.3));
          
          if (handStrength === 'monster') {
            if (canRaise && Math.random() < personality.aggression) {
              raiseInc = Math.min(ps.chips - callNeeded, Math.max(callNeeded, Math.floor(gameData.pot * 0.5)));
              action = 'RAISE';
            } else {
              action = 'CALL';
            }
          } else if (handStrength === 'strong' && (affordable || potOdds < 0.3)) {
            if (canRaise && Math.random() < personality.aggression * 0.7) {
              raiseInc = Math.min(ps.chips - callNeeded, Math.max(callNeeded, Math.floor(gameData.pot * 0.4)));
              action = 'RAISE';
            } else {
              action = 'CALL';
            }
          } else if (handStrength === 'medium' && affordable) {
            action = 'CALL';
          } else if (handStrength === 'pair' && (affordable || handScore > 1500)) {
            action = 'CALL';
          } else if (personality.tightness < 0.5 && affordable) {
            // Loose players call with weak hands sometimes
            action = 'CALL';
          } else {
            action = 'FOLD';
          }
        }
        
        if (action === 'RAISE' && raiseInc <= 0) {
          action = 'CALL';
        }
        
        aiActionGuard = true;
        handlePokerAction(action, raiseInc);
        aiActionGuard = false;
      }, 600);
    }

    function checkPokerRoundAdvance() {
      if (!gameData || gameData.status !== 'playing') return;
      
      const activePlayers = gameData.players.filter(p => !gameData.playerStates[p.id].folded);
      const bettingPlayers = activePlayers.filter(p => {
        const s = gameData.playerStates[p.id];
        return s.chips > 0 && !s.isAllIn;
      });
      
      if (activePlayers.length === 1) {
        resolvePokerShowdown(activePlayers[0].id);
        return;
      }
      
      const actionStart = gameData.actionStartIndex || 0;
      const currentIdx = (actionStart + gameData.turnIndex) % gameData.players.length;
      const currentP = gameData.players[currentIdx];
      const currentS = gameData.playerStates[currentP.id];
      
      // If current player is active and can act, wait for them
      const shouldWaitForPlayer = gameData.isMultiplayer 
        ? (currentP.id === currentUser.uid && currentS && !currentS.folded && !currentS.isAllIn && currentS.chips > 0)
        : (!currentP?.isAI && currentS && !currentS.folded && !currentS.isAllIn && currentS.chips > 0);
      
      if (shouldWaitForPlayer) {
        console.log('Waiting for current player to act:', currentP.name);
        return;
      }
      
      // If current player (AI or human) is folded/all-in/busted, skip their turn
      if (currentS && (currentS.folded || currentS.isAllIn || currentS.chips <= 0)) {
        const nextTurn = gameData.turnIndex + 1;
        const nextActorId = gameData.players[((gameData.actionStartIndex || 0) + nextTurn) % gameData.players.length].id;
        
        const updates = { turnIndex: nextTurn, expectedActorId: nextActorId };
        
        if (gameData.isMultiplayer && gameId) {
          updateDoc(doc(db, 'games', gameId), updates).catch(err => {
            console.error('Error updating game:', err);
          });
        } else {
          updateGameState(updates);
          setTimeout(() => {
            checkPokerRoundAdvance();
            if (isAITurn()) runPokerAI();
          }, 300);
        }
        return;
      }
      
      // Count how many active players have acted this round
      let activePlayerTurnCount = 0;
      
      // Count actual turns taken (turnIndex is how many actions have been completed)
      // If turnIndex = 0, nobody has acted yet
      // If turnIndex = 1, one player has acted
      // If turnIndex = 2, two players have acted
      activePlayerTurnCount = gameData.turnIndex;
      
      console.log('Turn counting:', {
        turnIndex: gameData.turnIndex,
        activePlayerTurnCount: activePlayerTurnCount,
        round: gameData.round,
        actionStartIndex: gameData.actionStartIndex
      });
      
      // Get count of players who still need to act
      const playersWhoCanAct = activePlayers.filter(p => {
        const s = gameData.playerStates[p.id];
        return !s.isAllIn && s.chips > 0;
      }).length;
      
      // In heads-up (2 players), both must act at least once in pre-flop
      // In other rounds, both must check/call after the flop
      const minActionsRequired = (gameData.players.length === 2 && gameData.round === 'pre-flop') 
        ? 2  // Both players must act in pre-flop
        : playersWhoCanAct;  // Normal requirement
      
      const allActed = activePlayerTurnCount >= minActionsRequired;
      const allMatchedBet = activePlayers.every(p => {
        const state = gameData.playerStates[p.id];
        return state.folded || state.contribution === gameData.currentBet || state.isAllIn || state.chips === 0;
      });

      console.log('checkPokerRoundAdvance details:', {
        round: gameData.round,
        turnIndex: gameData.turnIndex,
        activePlayerTurnCount,
        playersWhoCanAct,
        allActed,
        allMatchedBet,
        currentBet: gameData.currentBet,
        playerContributions: Object.fromEntries(
          gameData.players.map(p => [p.name, {
            contribution: gameData.playerStates[p.id].contribution,
            chips: gameData.playerStates[p.id].chips,
            folded: gameData.playerStates[p.id].folded,
            matchesBet: gameData.playerStates[p.id].contribution === gameData.currentBet
          }])
        ),
        activePlayers: activePlayers.map(p => p.name),
        actionStartIndex: gameData.actionStartIndex,
        pot: gameData.pot
      });

      // Check for fast-forward (all-in situation)
      const anyAllIn = activePlayers.some(p => gameData.playerStates[p.id].isAllIn);
      if (anyAllIn && allMatchedBet && !ffActive) {
        ffActive = true;
        const updates = { logs: [...(gameData.logs || []), "‚ö° FAST-FORWARD: All-in phase. Dealing..."] };
        
        if (gameData.isMultiplayer && gameId) {
          updateDoc(doc(db, 'games', gameId), updates).then(() => {
            setTimeout(() => runAutoDealer(gameData.round, gameData.deck, gameData.communityCards), 1000);
          }).catch(err => {
            console.error('Error updating game:', err);
          });
        } else {
          updateGameState(updates);
          setTimeout(() => runAutoDealer(gameData.round, gameData.deck, gameData.communityCards), 1000);
        }
        return;
      }

      if (allActed && allMatchedBet && !ffActive) {
        console.log('Advancing round: all acted and bets matched');
        
        // In multiplayer, only the first player (leader) advances the round
        if (gameData.isMultiplayer) {
          const amLeader = currentUser.uid === gameData.players[0].id;
          console.log('Am I the leader?', amLeader, 'My ID:', currentUser.uid, 'Leader ID:', gameData.players[0].id);
          
          // Additional check: has the round already been advanced?
          // If we're past pre-flop but turnIndex is still 0 and no one has acted, skip
          if (gameData.round !== 'pre-flop' && gameData.turnIndex === 0) {
            const noOneActedYet = gameData.players.every(p => {
              const s = gameData.playerStates[p.id];
              return s.contribution === 0;
            });
            
            if (noOneActedYet) {
              console.log('Round already advanced, waiting for first action');
              return;
            }
          }
          
          if (amLeader) {
            console.log('I am the leader, advancing round...');
            advancePokerRound();
          } else {
            console.log('Not the leader, waiting for leader to advance round');
          }
        } else {
          advancePokerRound();
        }
      } else if (gameData.turnIndex >= gameData.players.length * 2 && allMatchedBet && !ffActive) {
        // Safety check: if we've cycled through 2x the number of players and all bets are matched, force advance
        console.warn('Forcing round advance due to excessive turn count', {
          turnIndex: gameData.turnIndex,
          playerCount: gameData.players.length,
          allMatchedBet,
          allActed
        });
        
        // In multiplayer, only the first player (leader) advances the round
        if (gameData.isMultiplayer) {
          const amLeader = currentUser.uid === gameData.players[0].id;
          if (amLeader) {
            advancePokerRound();
          }
        } else {
          advancePokerRound();
        }
      } else if (!allActed || !allMatchedBet) {
        console.log('Waiting for actions:', { allActed, allMatchedBet, turnIndex: gameData.turnIndex });
      }
    }

    function runAutoDealer(currentRound, currentDeck, currentCommunity) {
      const rounds = { 'pre-flop': 'flop', 'flop': 'turn', 'turn': 'river', 'river': 'showdown' };
      const next = rounds[currentRound] || 'showdown';
      
      if (next === 'showdown') {
        ffActive = false;
        resolvePokerShowdown();
        return;
      }
      
      const counts = { 'flop': 3, 'turn': 1, 'river': 1 };
      const deck = [...currentDeck];
      const newCards = deck.splice(0, counts[next]);
      const communityCards = [...currentCommunity, ...newCards];
      
      const updates = {
        round: next,
        communityCards,
        deck,
        logs: [...(gameData.logs || []), `‚öôÔ∏è AUTO-DEAL: ${next.toUpperCase()}`]
      };
      
      if (gameData.isMultiplayer && gameId) {
        updateDoc(doc(db, 'games', gameId), updates).then(() => {
          setTimeout(() => runAutoDealer(next, deck, communityCards), 1200);
        }).catch(err => {
          console.error('Error updating game:', err);
        });
      } else {
        updateGameState(updates);
        setTimeout(() => runAutoDealer(next, deck, communityCards), 1200);
      }
    }

    function advancePokerRound() {
      const rounds = { 'pre-flop': 'flop', 'flop': 'turn', 'turn': 'river', 'river': 'showdown' };
      const next = rounds[gameData.round] || 'showdown';

      console.log('advancePokerRound called:', {
        currentRound: gameData.round,
        nextRound: next,
        isMultiplayer: gameData.isMultiplayer,
        gameId: gameId,
        currentCommunityCards: gameData.communityCards
      });

      if (next === 'showdown') {
        resolvePokerShowdown();
        return;
      }

      const counts = { 'flop': 3, 'turn': 1, 'river': 1 };
      const deck = [...gameData.deck];
      const newCards = deck.splice(0, counts[next]);
      const comm = [...gameData.communityCards, ...newCards];
      
      console.log('New community cards:', {
        newCards: newCards,
        totalCommunityCards: comm,
        deckRemaining: deck.length
      });
      
      const states = { ...gameData.playerStates };
      Object.keys(states).forEach(id => {
        // Preserve folded state, only reset contribution and raises
        states[id] = {
          ...states[id],
          contribution: 0,
          raisesThisRound: 0
        };
      });
      
      // Find first non-folded player after dealer to start the round
      let firstActiveIndex = ((gameData.dealerIndex ?? 0) + 1) % gameData.players.length;
      let searchCount = 0;
      while (searchCount < gameData.players.length) {
        const p = gameData.players[firstActiveIndex];
        if (!states[p.id].folded && !states[p.id].isAllIn && states[p.id].chips > 0) {
          break;
        }
        firstActiveIndex = (firstActiveIndex + 1) % gameData.players.length;
        searchCount++;
      }
      
      const updates = {
        round: next,
        communityCards: comm,
        deck,
        currentBet: 0,
        turnIndex: 0,
        actionStartIndex: firstActiveIndex,
        expectedActorId: gameData.players[firstActiveIndex].id,
        playerStates: states,
        logs: [...(gameData.logs || []), `üìç ${next.toUpperCase()}`]
      };
      
      console.log('Updating game state with:', updates);
      
      if (gameData.isMultiplayer && gameId) {
        console.log('Updating Firebase with community cards...');
        updateDoc(doc(db, 'games', gameId), updates).then(() => {
          console.log('Firebase update successful!');
        }).catch(err => {
          console.error('Error updating game:', err);
        });
      } else {
        updateGameState(updates);
        
        setTimeout(() => {
          if (isAITurn()) {
            runPokerAI();
          }
        }, 600);
      }
    }

    function resolvePokerShowdown(forcedWinner = null) {
      if (resolutionStarted) return;
      
      // In multiplayer, only the leader resolves the showdown
      if (gameData.isMultiplayer) {
        const amLeader = currentUser.uid === gameData.players[0].id;
        console.log('Resolving showdown - Am I leader?', amLeader);
        if (!amLeader) {
          console.log('Not the leader, waiting for leader to resolve showdown');
          return;
        }
      }
      
      resolutionStarted = true;
      
      const updates = { status: 'resolution' };
      
      if (gameData.isMultiplayer && gameId) {
        updateDoc(doc(db, 'games', gameId), updates).catch(err => {
          console.error('Error updating game:', err);
        });
      } else {
        updateGameState(updates);
      }

      setTimeout(() => {
        let winnerId = forcedWinner;
        
        if (!winnerId) {
          let best = -1;
          gameData.players.forEach(p => {
            if (!gameData.playerStates[p.id].folded) {
              const score = evaluateHand(
                gameData.playerStates[p.id].cards,
                gameData.communityCards
              );
              if (score > best) {
                best = score;
                winnerId = p.id;
              }
            }
          });
        }

        const states = { ...gameData.playerStates };
        if (states[winnerId]) {
          states[winnerId].chips += gameData.pot;
        }

        const winnerName = gameData.players.find(p => p.id === winnerId)?.name;
        const winnerHand = evaluateHandName(
          states[winnerId]?.cards || [],
          gameData.communityCards || []
        );
        
        // Track poker win if player won (only in single-player)
        if (!gameData.isMultiplayer) {
          if (winnerId === currentUser.uid) {
            updateStats({ 
              pokerWins: userStats.pokerWins + 1,
              totalWins: userStats.totalWins + 1,
              totalChips: states[winnerId].chips,
              gamesPlayed: userStats.gamesPlayed + 1
            });
          } else {
            updateStats({ 
              gamesPlayed: userStats.gamesPlayed + 1,
              totalChips: states[currentUser.uid]?.chips || userStats.totalChips
            });
          }
        }
        
        const resettingUpdates = {
          playerStates: states,
          pot: 0,
          status: 'resetting',
          logs: [...(gameData.logs || []), `üèÜ Winner: ${winnerName} with ${winnerHand}!`]
        };
        
        if (gameData.isMultiplayer && gameId) {
          updateDoc(doc(db, 'games', gameId), resettingUpdates).catch(err => {
            console.error('Error updating game:', err);
          });
        } else {
          updateGameState(resettingUpdates);
        }

        const newDeck = generateDeck();
        const resetStates = { ...states };
        
        const remainingPlayers = gameData.players.filter(p => resetStates[p.id].chips > 0);
        
        if (remainingPlayers.length === 1) {
          const finalWinner = remainingPlayers[0];
          
          // If player lost (not in remaining players), reset their chips to default (only single-player)
          if (!gameData.isMultiplayer && !remainingPlayers.some(p => p.id === currentUser.uid)) {
            updateStats({
              totalChips: 2000,
              gamesPlayed: userStats.gamesPlayed + 1
            });
          }
          
          const endUpdates = {
            status: 'ended',
            logs: [...resettingUpdates.logs, `üéâ GAME OVER! ${finalWinner.name || finalWinner.id} wins the game!`]
          };
          
          if (gameData.isMultiplayer && gameId) {
            updateDoc(doc(db, 'games', gameId), endUpdates).catch(err => {
              console.error('Error updating game:', err);
            });
          } else {
            updateGameState(endUpdates);
          }
          
          resolutionStarted = false;
          ffActive = false;
          return;
        }
        
        remainingPlayers.forEach(p => {
          resetStates[p.id] = {
            ...resetStates[p.id],
            folded: false,
            contribution: 0,
            isAllIn: false,
            raisesThisRound: 0,
            cards: newDeck.splice(0, 2)
          };
        });

        const dealerIndex = ((gameData.dealerIndex ?? 0) + 1) % remainingPlayers.length;
        const smallBlind = 10;
        const bigBlind = 20;
        
        let sbIndex, bbIndex, actionStartIndex;
        
        if (remainingPlayers.length === 2) {
          // Heads-up: Dealer is Small Blind, other player is Big Blind
          // Dealer acts first pre-flop
          sbIndex = dealerIndex;
          bbIndex = (dealerIndex + 1) % 2;
          actionStartIndex = dealerIndex;  // Dealer (SB) acts first
        } else {
          // 3+ players: Normal blind structure
          sbIndex = (dealerIndex + 1) % remainingPlayers.length;
          bbIndex = (dealerIndex + 2) % remainingPlayers.length;
          actionStartIndex = (bbIndex + 1) % remainingPlayers.length;  // After BB
        }
        
        const sbPlayer = remainingPlayers[sbIndex];
        const bbPlayer = remainingPlayers[bbIndex];
        if (resetStates[sbPlayer.id]) {
          resetStates[sbPlayer.id].contribution = smallBlind;
          resetStates[sbPlayer.id].chips -= smallBlind;
        }
        if (resetStates[bbPlayer.id]) {
          resetStates[bbPlayer.id].contribution = bigBlind;
          resetStates[bbPlayer.id].chips -= bigBlind;
        }
        
        const newRoundUpdates = {
          players: remainingPlayers,
          round: 'pre-flop',
          communityCards: [],
          deck: newDeck,
          currentBet: bigBlind,
          turnIndex: 0,
          actionStartIndex: actionStartIndex,
          expectedActorId: remainingPlayers[actionStartIndex].id,
          playerStates: resetStates,
          dealerIndex,
          pot: smallBlind + bigBlind,
          status: 'playing',
          logs: [...resettingUpdates.logs, 'üîÑ New Hand Started', `Blind cycle: SB $${smallBlind}, BB $${bigBlind}`]
        };
        
        if (gameData.isMultiplayer && gameId) {
          updateDoc(doc(db, 'games', gameId), newRoundUpdates).catch(err => {
            console.error('Error updating game:', err);
          });
        } else {
          updateGameState(newRoundUpdates);
          
          setTimeout(() => {
            if (isAITurn()) {
              runPokerAI();
            }
          }, 1000);
        }
        
        resolutionStarted = false;
        ffActive = false;
      }, 1500);
    }

    async function updateGameState(newData) {
      if (!currentUser) return;
      
      if (isMultiplayer && gameId) {
        await updateDoc(doc(db, 'games', gameId), newData);
      } else {
        gameData = { ...gameData, ...newData };
        render();
        
        // Run AI for strategy game
        if (gameData.type === GAME_TYPES.STRATEGY && gameData.turn === 'ai') {
          runStrategyAI();
        }
        
      }
    }

    // Initialize - Clear any anonymous sessions first
    (async () => {
      // Check if there's a persisted user that shouldn't be there
      const currentAuthUser = auth.currentUser;
      if (currentAuthUser && (!currentAuthUser.email || currentAuthUser.isAnonymous)) {
        console.log('Clearing invalid persisted session');
        await signOut(auth);
      }
    })();
    
    onAuthStateChanged(auth, async (user) => {
      // Validate that user has proper email authentication
      if (user && (!user.email || user.isAnonymous)) {
        // User is anonymous or doesn't have an email - sign them out
        console.log('Invalid auth state detected - signing out anonymous/invalid user');
        await signOut(auth);
        return;
      }
      
      currentUser = user;
      if (user) {
        // Load user stats from database
        await loadUserStats(user.uid);
        
        if (currentPage === 'auth') {
          currentPage = 'menu';
        }
      } else {
        currentPage = 'auth';
        gameData = null;
        // Reset stats to default
        userStats = {
          pokerWins: 0,
          strategyWins: 0,
          totalWins: 0,
          nodesSecured: 0,
          gamesPlayed: 0,
          totalChips: 2000
        };
      }
      render();
    });


    // Global arrow key handler for strategy game (only added once)
    document.addEventListener('keydown', (e) => {
      if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) return;
      if (currentPage !== 'game' || !gameData || gameData.type !== GAME_TYPES.STRATEGY) return;
      if (gameData.turn !== 'player' || gameData.status !== 'playing') return;
      
      e.preventDefault();
      
      const playerNodes = gameData.grid.filter(n => n.owner === 'player' || n.owner === currentUser?.uid);
      if (playerNodes.length === 0) return;
      
      if (selectedStrategyNode === null) {
        selectedStrategyNode = 0;
        const firstNode = playerNodes[0];
        const nodeIndex = gameData.grid.findIndex(n => n.id === firstNode.id);
        selectedStrategyNode = nodeIndex;
        render();
        return;
      }
      
      const currentNode = gameData.grid[selectedStrategyNode];
      
      // Find all nodes (owned and enemy) in the pressed direction
      let targetNode = null;
      let minDist = Infinity;
      
      gameData.grid.forEach(node => {
        if (node.id === currentNode.id) return;
        
        const dx = node.x - currentNode.x;
        const dy = node.y - currentNode.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        let isInDirection = false;
        if (e.key === 'ArrowRight' && dx > 0 && Math.abs(dy) < Math.abs(dx)) isInDirection = true;
        if (e.key === 'ArrowLeft' && dx < 0 && Math.abs(dy) < Math.abs(dx)) isInDirection = true;
        if (e.key === 'ArrowDown' && dy > 0 && Math.abs(dx) < Math.abs(dy)) isInDirection = true;
        if (e.key === 'ArrowUp' && dy < 0 && Math.abs(dx) < Math.abs(dy)) isInDirection = true;
        
        if (isInDirection && dist < minDist) {
          minDist = dist;
          targetNode = node;
        }
      });
      
      if (targetNode) {
        const nodeIndex = gameData.grid.findIndex(n => n.id === targetNode.id);
        const currentIndex = selectedStrategyNode;
        const sourceNode = gameData.grid[currentIndex];
        
        // Check if target is owned by player - transfer troops
        if ((targetNode.owner === 'player' || targetNode.owner === currentUser?.uid) && 
            (sourceNode.owner === 'player' || sourceNode.owner === currentUser?.uid) && 
            sourceNode.strength > 1) {
          // Get transfer amount from slider if it exists, otherwise transfer 1
          const slider = document.getElementById('transfer-slider');
          const transferAmount = slider ? parseInt(slider.value) : 1;
          
          const newGrid = gameData.grid.map(n => {
            if (n.id === sourceNode.id) return { ...n, strength: n.strength - transferAmount };
            if (n.id === targetNode.id) return { ...n, strength: n.strength + transferAmount };
            return n;
          });
          updateGameState({
            grid: newGrid,
            logs: [...gameData.logs, `‚û°Ô∏è Transferred ${transferAmount} troops from Node ${sourceNode.id} to Node ${targetNode.id}`]
          });
          selectedStrategyNode = nodeIndex;
          render();
        } 
        // Check if target is enemy/neutral and is a neighbor - attack
        else if (targetNode.owner !== 'player' && targetNode.owner !== currentUser?.uid) {
          const neighbors = getNeighbors(currentIndex);
          
          if (neighbors.includes(nodeIndex)) {
            if (gameData.energy < 2) {
              updateGameState({ logs: [...gameData.logs, "‚ö†Ô∏è Insufficient energy"] });
              return;
            }
            
            const newGrid = [...gameData.grid];
            const targetNodeCopy = { ...newGrid[nodeIndex] };
            const sourceNodeCopy = { ...newGrid[currentIndex] };
            
            if (sourceNodeCopy.strength > targetNodeCopy.strength) {
              targetNodeCopy.owner = 'player';
              targetNodeCopy.strength = 1;
              sourceNodeCopy.strength -= 1;
              newGrid[nodeIndex] = targetNodeCopy;
              newGrid[currentIndex] = sourceNodeCopy;
              
              // Track node capture
              updateStats({ nodesSecured: userStats.nodesSecured + 1 });
              
              updateGameState({ 
                grid: newGrid, 
                energy: gameData.energy - 2, 
                logs: [...gameData.logs, `üì° Captured [${targetNodeCopy.x}, ${targetNodeCopy.y}]`] 
              });
              selectedStrategyNode = nodeIndex;
              render();
            } else {
              targetNodeCopy.strength -= 1;
              sourceNodeCopy.strength -= 1;
              newGrid[nodeIndex] = targetNodeCopy;
              newGrid[currentIndex] = sourceNodeCopy;
              
              updateGameState({ 
                grid: newGrid, 
                energy: gameData.energy - 2, 
                logs: [...gameData.logs, `üí• Attack failed at [${targetNodeCopy.x}, ${targetNodeCopy.y}]`] 
              });
              render();
            }
          } else {
            // Not a neighbor, just select it
            selectedStrategyNode = nodeIndex;
            render();
          }
        }
        else {
          selectedStrategyNode = nodeIndex;
          render();
        }
      }
    });

    // Initial render
    render();
  </script>
</head>
<body class="bg-black">
  <div id="root"></div>
</body>
</html>
